{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"getting-started/","text":"Getting Started Info Don't want to follow the following steps by yourself? What about downloading a blueprint project that you can change according to your needs? Gradle+Kotlin Project [ Download ] [ Source Code ] Kos is mostly written in Java and carefully designed to be easily integrated other JVM languages like Kotlin and Scala. To import Kos you should include the following libraries on your project. Gradle (kts) dependencies { // Import the Bill of Materials implementation ( platform ( \"io.skullabs.kos:kos-bom: ${ version_kos } \" )) implementation ( \"io.skullabs.kos:kos-core\" ) compileOnly ( \"io.skullabs.kos:kos-annotations\" ) } Maven (pom.kts) dependencyManagement { dependencies { // Import the Bill of Materials import ( \"io.skullabs.kos:kos-bom: ${ kosVersion } \" ) } } dependencies { // Kos Dependencies compile ( \"io.skullabs.kos:kos-core\" ) compile ( \"io.skullabs.kos:kos-injector\" ) provided ( \"io.skullabs.kos:kos-annotations\" ) } Maven (pom.xml) <dependencyManagement> <dependencies> <!-- Import the Bill of Materials --> <dependency> <groupId> io.skullabs.kos </groupId> <artifactId> kos-bom </artifactId> <version> ${version_kos} </version> <type> pom </type> <scope> import </scope> </dependency> </dependencies> </dependencyManagement> <dependencies> <dependency> <groupId> io.skullabs.kos </groupId> <artifactId> kos-core </artifactId> </dependency> <dependency> <groupId> io.skullabs.kos </groupId> <artifactId> kos-annotations </artifactId> </dependency> </dependency> Now let's create a simple HelloWorld API. Kotlin @Path ( \"hello\" ) class HelloWorldApi { @GET ( \"world\" ) fun sayHello () = \"Hello World\" } Java @Path ( \"hello\" ) class HelloWorldApi { @GET ( \"world\" ) String sayHello () { return \"Hello World\" ; } } Finally, we have to bundle all dependencies together and generate a runnable jar with them. Gradle (kts) // You can use either Shadow or VertX plugin to generate a fat jar // We've picked VertX in this example plugins { id ( \"io.vertx.vertx-plugin\" ) version \"1.2.0\" } vertx { launcher = launcherClass } Maven (pom.kts) plugins { plugin ( \"org.apache.maven.plugins:maven-shade-plugin:3.2.0\" ) { executions { execution ( id = \"default-package\" , phase = \"package\" , goals = listOf ( \"shade\" )) } configuration { \"createDependencyReducedPom\" to true \"dependencyReducedPomLocation\" to \"\\ ${ project . build . directory } /pom-reduced.xml\" \"transformers\" { \"org.apache.maven.plugins.shade.resource.ServicesResourceTransformer\" {} \"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\" { \"manifestEntries\" { \"Main-Class\" to launcherClass } } } } } } Maven (pom.xml) <plugin> <artifactId> maven-shade-plugin </artifactId> <version> 3.2.0 </version> <executions> <execution> <id> default-package </id> <phase> package </phase> <goals> <goal> shade </goal> </goals> <configuration> <createDependencyReducedPom> true </createDependencyReducedPom> <dependencyReducedPomLocation> ${project.build.directory}/pom-reduced.xml </dependencyReducedPomLocation> <transformers> <org.apache.maven.plugins.shade.resource.ServicesResourceTransformer /> <org.apache.maven.plugins.shade.resource.ManifestResourceTransformer> <manifestEntries> <Main-Class> kos.core.Launcher </Main-Class> </manifestEntries> </org.apache.maven.plugins.shade.resource.ManifestResourceTransformer> </transformers> </configuration> </execution> </executions> </plugin> Voila ! Our first Kos software is ready. Let's run it? Gradle $ java -jar build/libs/my-kos-app-all.jar Maven $ java -jar target/my-kos-app.jar","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"Info Don't want to follow the following steps by yourself? What about downloading a blueprint project that you can change according to your needs? Gradle+Kotlin Project [ Download ] [ Source Code ] Kos is mostly written in Java and carefully designed to be easily integrated other JVM languages like Kotlin and Scala. To import Kos you should include the following libraries on your project. Gradle (kts) dependencies { // Import the Bill of Materials implementation ( platform ( \"io.skullabs.kos:kos-bom: ${ version_kos } \" )) implementation ( \"io.skullabs.kos:kos-core\" ) compileOnly ( \"io.skullabs.kos:kos-annotations\" ) } Maven (pom.kts) dependencyManagement { dependencies { // Import the Bill of Materials import ( \"io.skullabs.kos:kos-bom: ${ kosVersion } \" ) } } dependencies { // Kos Dependencies compile ( \"io.skullabs.kos:kos-core\" ) compile ( \"io.skullabs.kos:kos-injector\" ) provided ( \"io.skullabs.kos:kos-annotations\" ) } Maven (pom.xml) <dependencyManagement> <dependencies> <!-- Import the Bill of Materials --> <dependency> <groupId> io.skullabs.kos </groupId> <artifactId> kos-bom </artifactId> <version> ${version_kos} </version> <type> pom </type> <scope> import </scope> </dependency> </dependencies> </dependencyManagement> <dependencies> <dependency> <groupId> io.skullabs.kos </groupId> <artifactId> kos-core </artifactId> </dependency> <dependency> <groupId> io.skullabs.kos </groupId> <artifactId> kos-annotations </artifactId> </dependency> </dependency> Now let's create a simple HelloWorld API. Kotlin @Path ( \"hello\" ) class HelloWorldApi { @GET ( \"world\" ) fun sayHello () = \"Hello World\" } Java @Path ( \"hello\" ) class HelloWorldApi { @GET ( \"world\" ) String sayHello () { return \"Hello World\" ; } } Finally, we have to bundle all dependencies together and generate a runnable jar with them. Gradle (kts) // You can use either Shadow or VertX plugin to generate a fat jar // We've picked VertX in this example plugins { id ( \"io.vertx.vertx-plugin\" ) version \"1.2.0\" } vertx { launcher = launcherClass } Maven (pom.kts) plugins { plugin ( \"org.apache.maven.plugins:maven-shade-plugin:3.2.0\" ) { executions { execution ( id = \"default-package\" , phase = \"package\" , goals = listOf ( \"shade\" )) } configuration { \"createDependencyReducedPom\" to true \"dependencyReducedPomLocation\" to \"\\ ${ project . build . directory } /pom-reduced.xml\" \"transformers\" { \"org.apache.maven.plugins.shade.resource.ServicesResourceTransformer\" {} \"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\" { \"manifestEntries\" { \"Main-Class\" to launcherClass } } } } } } Maven (pom.xml) <plugin> <artifactId> maven-shade-plugin </artifactId> <version> 3.2.0 </version> <executions> <execution> <id> default-package </id> <phase> package </phase> <goals> <goal> shade </goal> </goals> <configuration> <createDependencyReducedPom> true </createDependencyReducedPom> <dependencyReducedPomLocation> ${project.build.directory}/pom-reduced.xml </dependencyReducedPomLocation> <transformers> <org.apache.maven.plugins.shade.resource.ServicesResourceTransformer /> <org.apache.maven.plugins.shade.resource.ManifestResourceTransformer> <manifestEntries> <Main-Class> kos.core.Launcher </Main-Class> </manifestEntries> </org.apache.maven.plugins.shade.resource.ManifestResourceTransformer> </transformers> </configuration> </execution> </executions> </plugin> Voila ! Our first Kos software is ready. Let's run it? Gradle $ java -jar build/libs/my-kos-app-all.jar Maven $ java -jar target/my-kos-app.jar","title":"Getting Started"},{"location":"license/","text":"License Copyright 2018-2021 Skullabs Contributors. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"license/#license","text":"Copyright 2018-2021 Skullabs Contributors. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"manual/architecture/implementation-loaders/","text":"Implementation Loaders Internally, Kos refers to Dependency Injection mechanisms as Implementation Loaders . They are responsible to perform two basic tasks the Kos needs all the time: Load an object implementing a given Interface - or extending a given class Load all objects implementing a given Interface - or extending a given class Types of Implementation Loaders The next topics will cover all DI mechanism provided out-of-box with Kos. Injector Injector is lightweight and zero-overhead, dependency injection library for JVM developers. It was carefully designed to make no-use of reflection by having all required meta-information computed at compile time. At runtime, it performs only the necessary tasks required to instantiate classes and have its dependencies injected. The result is a blistering fast Dependency Injection implementation that has around 7kb of footprint. To provide an implementation of a given Kos service, all you have to do is implement a given interface (or extend a given class) and annotate with injector.Exposed annotation. Also, to make ordinary classes able to be managed by Injector you should annotate them with either injector.Singleton or injector.New . Info For more details on how Injector works, please proceed to its documentation . Below you can find a Custom Exception Handler implementation. import injector.Exposed ; import kos.api.ExceptionHandler ; import kos.api.Response ; @ExposedAs ( ExceptionHandler . class ) public class CustomExceptionHandler implements ExceptionHandler { public Response handle ( RoutingContext request , Throwable cause ){ if ( cause instanceof IllegalArgumentException ) return Response . BAD_REQUEST ; return Response . of ( cause . getMessage ()). statusCode ( 500 ); } } To use Injector as default Implementation Loader you need to import kos-injector module on your project. Gradle (kts) implementation ( \"io.skullabs.kos:kos-injector\" ) Maven (pom.kts) compile ( \"io.skullabs.kos:kos-injector\" ) Maven (pom.xml) <dependency> <groupId> io.skullabs.kos </groupId> <artifactId> kos-injector </artifactId> </dependency> Custom Dependency Injection Mechanism As mentioned before, the Implementation Loader is a simple mechanism and doesn't enforce you to stick with a single implementation. To provide your own Implementation Loader you need to implement the kos.api.ImplementationLoader interface. Once you've implemented you need to register it as the default Implementation Loader by exposing it as Service Provider implementation. You can do so by creating a META-INF/services/kos.api.ImplementationLoader file containing the canonical name of your just created class.","title":"Implementation Loaders"},{"location":"manual/architecture/implementation-loaders/#implementation-loaders","text":"Internally, Kos refers to Dependency Injection mechanisms as Implementation Loaders . They are responsible to perform two basic tasks the Kos needs all the time: Load an object implementing a given Interface - or extending a given class Load all objects implementing a given Interface - or extending a given class","title":"Implementation Loaders"},{"location":"manual/architecture/implementation-loaders/#types-of-implementation-loaders","text":"The next topics will cover all DI mechanism provided out-of-box with Kos.","title":"Types of Implementation Loaders"},{"location":"manual/architecture/implementation-loaders/#injector","text":"Injector is lightweight and zero-overhead, dependency injection library for JVM developers. It was carefully designed to make no-use of reflection by having all required meta-information computed at compile time. At runtime, it performs only the necessary tasks required to instantiate classes and have its dependencies injected. The result is a blistering fast Dependency Injection implementation that has around 7kb of footprint. To provide an implementation of a given Kos service, all you have to do is implement a given interface (or extend a given class) and annotate with injector.Exposed annotation. Also, to make ordinary classes able to be managed by Injector you should annotate them with either injector.Singleton or injector.New . Info For more details on how Injector works, please proceed to its documentation . Below you can find a Custom Exception Handler implementation. import injector.Exposed ; import kos.api.ExceptionHandler ; import kos.api.Response ; @ExposedAs ( ExceptionHandler . class ) public class CustomExceptionHandler implements ExceptionHandler { public Response handle ( RoutingContext request , Throwable cause ){ if ( cause instanceof IllegalArgumentException ) return Response . BAD_REQUEST ; return Response . of ( cause . getMessage ()). statusCode ( 500 ); } } To use Injector as default Implementation Loader you need to import kos-injector module on your project. Gradle (kts) implementation ( \"io.skullabs.kos:kos-injector\" ) Maven (pom.kts) compile ( \"io.skullabs.kos:kos-injector\" ) Maven (pom.xml) <dependency> <groupId> io.skullabs.kos </groupId> <artifactId> kos-injector </artifactId> </dependency>","title":"Injector"},{"location":"manual/architecture/implementation-loaders/#custom-dependency-injection-mechanism","text":"As mentioned before, the Implementation Loader is a simple mechanism and doesn't enforce you to stick with a single implementation. To provide your own Implementation Loader you need to implement the kos.api.ImplementationLoader interface. Once you've implemented you need to register it as the default Implementation Loader by exposing it as Service Provider implementation. You can do so by creating a META-INF/services/kos.api.ImplementationLoader file containing the canonical name of your just created class.","title":"Custom Dependency Injection Mechanism"},{"location":"manual/architecture/internal-events/","text":"Internal Events Kos triggers a few events during the application bootstrap. It might be particularly useful to customize how Vert.x will behave internally, allowing developers to deploy custom verticles or even changing Kos' default configuration parameters. Web Server events By exposing an implementation of the interface kos.api.WebServerEventListener , your code will be notified before the web server is instantiated and its routes are deployed. This might be useful to deploy custom routes, or tweaking the web server nobs to your needs. Note : this event won't be triggered if the default WebServer verticle is turned off. Kotlin @Exposed class MyWebListener : WebServerEventListener { fun on ( event : BeforeDeployWebServerEvent ) { TODO ( \"Implement me!\" ) } } Java @Exposed class MyWebListener implements WebServerEventListener { public void on ( BeforeDeployWebServerEvent event ) { throw new UnsupportedOperationException ( \"Implement me!\" ); } } Configuration Loaded events By exposing an implementation of the interface kos.api.ConfigurationLoadedListener , developers will be notified whenever the whole application is about to be started. It allow one to read the whole configuration of the software. Kotlin @Exposed class MyCustomAppBootstrap : ConfigurationLoadedEventListener { fun on ( event : ConfigurationLoadedEvent ) { TODO ( \"Implement me!\" ) } } Java @Exposed class MyCustomAppBootstrap implements ConfigurationLoadedEventListener { public void on ( ConfigurationLoadedEventListener event ) { throw new UnsupportedOperationException ( \"Implement me!\" ); } }","title":"Internal Events"},{"location":"manual/architecture/internal-events/#internal-events","text":"Kos triggers a few events during the application bootstrap. It might be particularly useful to customize how Vert.x will behave internally, allowing developers to deploy custom verticles or even changing Kos' default configuration parameters.","title":"Internal Events"},{"location":"manual/architecture/internal-events/#web-server-events","text":"By exposing an implementation of the interface kos.api.WebServerEventListener , your code will be notified before the web server is instantiated and its routes are deployed. This might be useful to deploy custom routes, or tweaking the web server nobs to your needs. Note : this event won't be triggered if the default WebServer verticle is turned off. Kotlin @Exposed class MyWebListener : WebServerEventListener { fun on ( event : BeforeDeployWebServerEvent ) { TODO ( \"Implement me!\" ) } } Java @Exposed class MyWebListener implements WebServerEventListener { public void on ( BeforeDeployWebServerEvent event ) { throw new UnsupportedOperationException ( \"Implement me!\" ); } }","title":"Web Server events"},{"location":"manual/architecture/internal-events/#configuration-loaded-events","text":"By exposing an implementation of the interface kos.api.ConfigurationLoadedListener , developers will be notified whenever the whole application is about to be started. It allow one to read the whole configuration of the software. Kotlin @Exposed class MyCustomAppBootstrap : ConfigurationLoadedEventListener { fun on ( event : ConfigurationLoadedEvent ) { TODO ( \"Implement me!\" ) } } Java @Exposed class MyCustomAppBootstrap implements ConfigurationLoadedEventListener { public void on ( ConfigurationLoadedEventListener event ) { throw new UnsupportedOperationException ( \"Implement me!\" ); } }","title":"Configuration Loaded events"},{"location":"manual/architecture/kos-plugins/","text":"Kos Plugins Kos Plugins are useful to change how any internal component will work on Kos, being it provided by Kos itself or a Vert.x one. The Kos Context kos.api.KosContext is the backbone of the system, contains all basic components in which Kos will interact with. Thus, to avoid misconfiguration, there will be only one instance of this object (managed by Kos) in the whole application. The only way to mutate its content is by creating a kos.api.Plugin implementation. Creating a Plugin Creating a plugin is easy. All it's needed is exposing an implementation of the interface kos.api.Plugin and you will have access to a mutable instance of kos.api.KosContext . Kotlin @Exposed class MyWebListener : Plugin { fun configure ( kosContext : MutableKosContext ) { TODO ( \"Implement me!\" ) } } Java @Exposed class MyWebListener implements Plugin { public void configure ( MutableKosContext kosContext ) { throw new UnsupportedOperationException ( \"Implement me!\" ); } }","title":"Plugins"},{"location":"manual/architecture/kos-plugins/#kos-plugins","text":"Kos Plugins are useful to change how any internal component will work on Kos, being it provided by Kos itself or a Vert.x one.","title":"Kos Plugins"},{"location":"manual/architecture/kos-plugins/#the-kos-context","text":"kos.api.KosContext is the backbone of the system, contains all basic components in which Kos will interact with. Thus, to avoid misconfiguration, there will be only one instance of this object (managed by Kos) in the whole application. The only way to mutate its content is by creating a kos.api.Plugin implementation.","title":"The Kos Context"},{"location":"manual/architecture/kos-plugins/#creating-a-plugin","text":"Creating a plugin is easy. All it's needed is exposing an implementation of the interface kos.api.Plugin and you will have access to a mutable instance of kos.api.KosContext . Kotlin @Exposed class MyWebListener : Plugin { fun configure ( kosContext : MutableKosContext ) { TODO ( \"Implement me!\" ) } } Java @Exposed class MyWebListener implements Plugin { public void configure ( MutableKosContext kosContext ) { throw new UnsupportedOperationException ( \"Implement me!\" ); } }","title":"Creating a Plugin"},{"location":"manual/developer/basic-concepts/","text":"Basic Concepts Kos is just a tiny opinionated layer that wraps all the basic functionality we love from Vert.x behind a simple syntax. In this page we will enumerate the concepts that you need to learn before you use Kos. Motivation Vert.x is a JVM reactive toolkit. From Database queries to web apis, it aims to provide all the benefits of the reactive paradigm when developing services. However, as reactive APIs, in general, are slightly more elaborate than traditional imperative programming, using it for big projects might be challenging. Consider the following sample code: class Server : AbstractVerticle () { override fun start () { vertx . createHttpServer (). requestHandler { req -> val queryParams = context . queryParams (); val name = queryParams . get ( \"name\" ) ?: \"World\" ; req . response () . putHeader ( \"content-type\" , \"text/plain\" ) . end ( \"Hello $ name \" ) }. listen ( 8080 ) } } It is supposed to be a simple Hello $name endpoint, but it hides a few challenges to those unfamiliar with Vert.x or reactive programming. A wise developer will certainly identify that this class has two responsibilities and will segregate this into (at least) two different units: the controller and business logic. class HelloBusiness { fun sayHelloTo ( name : String ) = \"Hello $ name \" } class Server : AbstractVerticle () { private val helloBusiness = HelloBusiness () override fun start () { vertx . createHttpServer (). requestHandler { req -> val queryParams = context . queryParams (); val name = queryParams . get ( \"name\" ) ?: \"World\" ; val response = helloBusiness . sayHelloTo ( name ) req . response () . putHeader ( \"content-type\" , \"text/plain\" ) . end ( response ) }. listen ( 8080 ) } } For this small example, it doesn't worth the effort: the Server class is a bit more complex, and the business logic is a just a single line. In the real world, though, this design actually pays off. The current design certainly increased clarity of the business layer, the one which is more likely to expand as the time passes by. If we expand this example ever further, this simple would become unmaintainable. Imagine what would happen if try to persist users, parse input parameters, deserialize request payload or externalize the server configuration through to a configuration file. Unless you have strong discipline, it's fairly likely that this project would soon become a big ball of mud on its early stages. Annotation Processors Vert.x is rather powerful though. It was designed as a toolkit, and can be used to design almost everything. Kos helps developers to focus on the business layer by generating the code that \"glues\" it to Vert.x. This is process happens at compile time through the Annotation Processing Tool provided by the JDK. This allows you to develop something like the code below and achieve the same result as our previous example. @RestApi class HelloBusiness { @GET fun sayHelloTo ( @Param name : String ) = \"Hello $ name \" } Dependency Injection As they are generated at compile time, Kos needs a way to figure out how to discover and instantiate these classes. This is why Kos makes usage of a tiny Dependency Injection (DI) library called Injector . Whenever the server is initialised, Kos will ask Injector for Web Routes, Validators, Event Listeners and other Vert.x components that might have been created during the compilation process. Info You can check the Dependency Injection guide in case you want to a different DI library as a replacement for Injector. Implementation Discovery Most of the Kos components are trivial to be configured. However, you might be asked to \"Expose\" an implementation of a given interface, so Kos can find it during the bootstrap process. There are two annotations that can be used to make an interface implementation discoverable (or exposed): injector.Exposed and injector.ExposedAs . ExposedAs is used to explicitly expose the current class as an implementation of a given interface (or superclass) Exposed will expose the current to all interfaces it is directly implementing (ignoring superinterfaces or interfaces implemented by its superclass). Automatically discovered classes As the annotation process takes place, a few classes will be generated making the target class automatically exposed on the Class Path. Classes (or classes which methods are) annotated with the following Kos annotations will be automatically exposed: @RestApi @Listener @Validates The Launcher Kos has a small bootstrap class called kos.core.Launcher that will automatically spin up the server. With a little help from our DI, it will read the Vert.x configuration and deploy all verticles found on the class path. So, make sure you set this class as your Main-Class and your application good to go. Kos Context The kos.api.KosContext object contains all the internal components managed by Kos. This includes: - io.vertx.core.Vertx instance - used whenever interacting with Vert.x components - Log configuration - Serialization mechanisms (for both Rest API and Clients) - Implementation Loader (Dependency Injection) configuration","title":"Basic Concepts"},{"location":"manual/developer/basic-concepts/#basic-concepts","text":"Kos is just a tiny opinionated layer that wraps all the basic functionality we love from Vert.x behind a simple syntax. In this page we will enumerate the concepts that you need to learn before you use Kos.","title":"Basic Concepts"},{"location":"manual/developer/basic-concepts/#motivation","text":"Vert.x is a JVM reactive toolkit. From Database queries to web apis, it aims to provide all the benefits of the reactive paradigm when developing services. However, as reactive APIs, in general, are slightly more elaborate than traditional imperative programming, using it for big projects might be challenging. Consider the following sample code: class Server : AbstractVerticle () { override fun start () { vertx . createHttpServer (). requestHandler { req -> val queryParams = context . queryParams (); val name = queryParams . get ( \"name\" ) ?: \"World\" ; req . response () . putHeader ( \"content-type\" , \"text/plain\" ) . end ( \"Hello $ name \" ) }. listen ( 8080 ) } } It is supposed to be a simple Hello $name endpoint, but it hides a few challenges to those unfamiliar with Vert.x or reactive programming. A wise developer will certainly identify that this class has two responsibilities and will segregate this into (at least) two different units: the controller and business logic. class HelloBusiness { fun sayHelloTo ( name : String ) = \"Hello $ name \" } class Server : AbstractVerticle () { private val helloBusiness = HelloBusiness () override fun start () { vertx . createHttpServer (). requestHandler { req -> val queryParams = context . queryParams (); val name = queryParams . get ( \"name\" ) ?: \"World\" ; val response = helloBusiness . sayHelloTo ( name ) req . response () . putHeader ( \"content-type\" , \"text/plain\" ) . end ( response ) }. listen ( 8080 ) } } For this small example, it doesn't worth the effort: the Server class is a bit more complex, and the business logic is a just a single line. In the real world, though, this design actually pays off. The current design certainly increased clarity of the business layer, the one which is more likely to expand as the time passes by. If we expand this example ever further, this simple would become unmaintainable. Imagine what would happen if try to persist users, parse input parameters, deserialize request payload or externalize the server configuration through to a configuration file. Unless you have strong discipline, it's fairly likely that this project would soon become a big ball of mud on its early stages.","title":"Motivation"},{"location":"manual/developer/basic-concepts/#annotation-processors","text":"Vert.x is rather powerful though. It was designed as a toolkit, and can be used to design almost everything. Kos helps developers to focus on the business layer by generating the code that \"glues\" it to Vert.x. This is process happens at compile time through the Annotation Processing Tool provided by the JDK. This allows you to develop something like the code below and achieve the same result as our previous example. @RestApi class HelloBusiness { @GET fun sayHelloTo ( @Param name : String ) = \"Hello $ name \" }","title":"Annotation Processors"},{"location":"manual/developer/basic-concepts/#dependency-injection","text":"As they are generated at compile time, Kos needs a way to figure out how to discover and instantiate these classes. This is why Kos makes usage of a tiny Dependency Injection (DI) library called Injector . Whenever the server is initialised, Kos will ask Injector for Web Routes, Validators, Event Listeners and other Vert.x components that might have been created during the compilation process. Info You can check the Dependency Injection guide in case you want to a different DI library as a replacement for Injector.","title":"Dependency Injection"},{"location":"manual/developer/basic-concepts/#implementation-discovery","text":"Most of the Kos components are trivial to be configured. However, you might be asked to \"Expose\" an implementation of a given interface, so Kos can find it during the bootstrap process. There are two annotations that can be used to make an interface implementation discoverable (or exposed): injector.Exposed and injector.ExposedAs . ExposedAs is used to explicitly expose the current class as an implementation of a given interface (or superclass) Exposed will expose the current to all interfaces it is directly implementing (ignoring superinterfaces or interfaces implemented by its superclass).","title":"Implementation Discovery"},{"location":"manual/developer/basic-concepts/#automatically-discovered-classes","text":"As the annotation process takes place, a few classes will be generated making the target class automatically exposed on the Class Path. Classes (or classes which methods are) annotated with the following Kos annotations will be automatically exposed: @RestApi @Listener @Validates","title":"Automatically discovered classes"},{"location":"manual/developer/basic-concepts/#the-launcher","text":"Kos has a small bootstrap class called kos.core.Launcher that will automatically spin up the server. With a little help from our DI, it will read the Vert.x configuration and deploy all verticles found on the class path. So, make sure you set this class as your Main-Class and your application good to go.","title":"The Launcher"},{"location":"manual/developer/basic-concepts/#kos-context","text":"The kos.api.KosContext object contains all the internal components managed by Kos. This includes: - io.vertx.core.Vertx instance - used whenever interacting with Vert.x components - Log configuration - Serialization mechanisms (for both Rest API and Clients) - Implementation Loader (Dependency Injection) configuration","title":"Kos Context"},{"location":"manual/developer/config-files/","text":"Reading Configuration File Kos will use Vert.x's core api to read Yaml configuration files available in the class path. Once the configuration is read, you will have a JsonObject which you can interact with and read the desired configuration property. By default, Kos will for a file called application.yml in the classpath. In case more than one is found, all application.yml found in the classpath will be merged before being used. Reading the configuration object Reading the configuration file and transforming it into an object that can be accessed globally in the application is a common pattern nowadays. Kos provides a different approach to tackle this problem: event-driven configuration. All you will need do is to expose an implementation of the ConfigurationLoadedListener.Event interface. Note As your class is annotated with @Exposed annotation, you can inject other components. Check the Injector for more details. Kotlin @Exposed class MyAppConfigPlugin : ConfigurationLoadedEventListener { fun on ( event : ConfigurationLoadedEvent ) { val vertxConf = event . applicationConfig val remoteUrl = URL ( vertxConf . getString ( \"myapp.remote.url\" )) // do something with the `remoteUrl` } } @Exposed class MyAppConfigPlugin implements ConfigurationLoadedEventListener { @Override public void on ( ConfigurationLoadedEvent event ) { try { JsonObject vertxConf = event . getApplicationConfig (); URL remoteUrl = new URL ( vertxConf . getString ( \"myapp.remote.url\" )); // do something with the `remoteUrl` } catch ( MalformedURLException cause ) { cause . printStackTrace (); } } }","title":"Configuration File"},{"location":"manual/developer/config-files/#reading-configuration-file","text":"Kos will use Vert.x's core api to read Yaml configuration files available in the class path. Once the configuration is read, you will have a JsonObject which you can interact with and read the desired configuration property. By default, Kos will for a file called application.yml in the classpath. In case more than one is found, all application.yml found in the classpath will be merged before being used.","title":"Reading Configuration File"},{"location":"manual/developer/config-files/#reading-the-configuration-object","text":"Reading the configuration file and transforming it into an object that can be accessed globally in the application is a common pattern nowadays. Kos provides a different approach to tackle this problem: event-driven configuration. All you will need do is to expose an implementation of the ConfigurationLoadedListener.Event interface. Note As your class is annotated with @Exposed annotation, you can inject other components. Check the Injector for more details. Kotlin @Exposed class MyAppConfigPlugin : ConfigurationLoadedEventListener { fun on ( event : ConfigurationLoadedEvent ) { val vertxConf = event . applicationConfig val remoteUrl = URL ( vertxConf . getString ( \"myapp.remote.url\" )) // do something with the `remoteUrl` } } @Exposed class MyAppConfigPlugin implements ConfigurationLoadedEventListener { @Override public void on ( ConfigurationLoadedEvent event ) { try { JsonObject vertxConf = event . getApplicationConfig (); URL remoteUrl = new URL ( vertxConf . getString ( \"myapp.remote.url\" )); // do something with the `remoteUrl` } catch ( MalformedURLException cause ) { cause . printStackTrace (); } } }","title":"Reading the configuration object"},{"location":"manual/developer/logging/","text":"Logging Configuration Kos uses SLF4J as main logging implementation. Vert.x internal logging is also automatically configured to use SLF4J as its default logging mechanism. Injecting the logger Kos allows developers to inject SLF4J Loggers into their components. Kotlin import org.slf4j.Logger; @Service class MyComponent ( val logger : Logger ) { } Java import org.slf4j.Logger ; @Service class MyComponent { Logger logger ; MyComponent ( Logger logger ) { this . logger = logger ; } }","title":"Logging"},{"location":"manual/developer/logging/#logging-configuration","text":"Kos uses SLF4J as main logging implementation. Vert.x internal logging is also automatically configured to use SLF4J as its default logging mechanism.","title":"Logging Configuration"},{"location":"manual/developer/logging/#injecting-the-logger","text":"Kos allows developers to inject SLF4J Loggers into their components. Kotlin import org.slf4j.Logger; @Service class MyComponent ( val logger : Logger ) { } Java import org.slf4j.Logger ; @Service class MyComponent { Logger logger ; MyComponent ( Logger logger ) { this . logger = logger ; } }","title":"Injecting the logger"},{"location":"manual/developer/rest-apis/","text":"Rest API Write down rest API's with Kos is dead simple and, if you've been using Java ecosystem in the last few years you're probably at home. First, be sure you've included kos-annotations in your compilation Class Path, and double-check if you have enabled APT compilation as well (enabled by default only in Java projects). Gradle (kts) compileOnly ( \"io.skullabs.kos:kos-annotations\" ) Maven (pom.kts) provided ( \"io.skullabs.kos:kos-annotations\" ) Maven (pom.xml) <dependency> <groupId> io.skullabs.kos </groupId> <artifactId> kos-annotations </artifactId> <scope> provided </scope> </dependency> Classes as API entrypoints Kos relies on JVM classes as entrypoint for your APIs. That said, you should identify your class with the kos.rest.RestApi annotation. It will allow Kos to monitor this class for routes. Kotlin import kos.rest.* @RestApi class MyApi { } Java import kos.rest.* ; @RestApi class MyApi { } If your API contains a common root path that could be shared by two or more endpoints, you can set a root path for you API using the RestApi annotation. Kotlin import kos.rest.* @RestApi ( \"/money\" ) class MyApi { } Java import kos.rest.* ; @RestApi ( \"/money\" ) class MyApi { } Exposing Methods as Rest endpoints Out-of-box you can expose any public or package default method as Rest endpoint by using one of the following annotations: kos.rest.GET kos.rest.POST kos.rest.PUT kos.rest.DELETE kos.rest.PATCH Defining URIs for your endpoints Just as kos.rest.RestApi can be used to map a (root) path to an endpoint, the above mentioned annotations can also be used to define a more specific endpoint URI for your methods. In the below example we have two methods exposed as Rest endpoints: MyApi.getMoney will be exposed as GET operation mapped to /money URI. MyApi.getMoreMoney will also be exposed as GET operation, but mapped to /money/double URI. Kotlin import kos.rest.* @RestApi ( \"/money\" ) class MyApi { @GET fun getMoney () = 10 @GET ( \"/double\" ) fun getMoreMoney () = getMoney () * 2 } Java import kos.rest.* ; @RestApi ( \"/money\" ) class MyApi { @GET Integer getMoney (){ return 10 ; } @GET ( \"/double\" ) Integer getMoreMoney (){ return getMoney () * 2 ; } } Sending responses to the Http Client Kos Rest API's will infer the response from the return type defined on your functions: kos.api.Response : this is a special response type bundled in Kos so developers can easily define custom responses to Http Clients. It is particularly useful when you method needs to return different types of Response objects, or different types of Http Status Responses. void : methods that doesn't return a value will make your method API receive the request, perform all the synchronous tasks defined within it and immediately return 204 as default answer. io.vertx.core.Future<?> : by returning Vert.x's Future your Http Clients will wait for the the Future to be completed to receive a response. In case of a success result, the object by the Future instance will be serialized and a successful response will be sent. On the other hand, if your Future holds a failure result, an error message will be sent. Plain Objects: API's that returns plain object will have it's returned object serialized via Default Serializer mechanism and sent as response to your Http Client. How serialization work? Successful responses are automatically serialized through the Default Serializer mechanism. However, in case an exception has been thrown or returned as Future response, the default Exception Handler mechanism will be in charge of converting it into an Http Response. Kotlin import kos.rest.* import io.vertx.core.* import java.util.concurrent.ThreadLocalRandom @RestApi ( \"/money\" ) class MyApi { @GET fun getMoney (): Future < Integer > { val money = Promise . promise () /* * Compute my money. It can be done using any asynchronous operation * as long as you don't block Vert.x's Event Loop. */ return money . future () } @GET ( \"/random\" ) fun getMoreMoney () = return ThreadLocalRandom . current (). nextInt (); @POST fun generateMoney (){ println ( \"This might increase the inflation!\" ) val generated = ThreadLocalRandom . current (). nextInt () println ( \"Generated money: $ $ generated .00\" ); } } Java import kos.rest.* ; import io.vertx.core.* ; import java.util.concurrent.ThreadLocalRandom ; @RestApi ( \"/money\" ) class MyApi { @GET Future < Integer > getMoney (){ Promise < Integer > money = Promise . promise (); /* * Compute my money. It can be done using any asynchronous operation * as long as you don't block Vert.x's Event Loop. */ return money . future (); } @GET ( \"/random\" ) Integer getMoreMoney (){ return ThreadLocalRandom . current (). nextInt (); } @POST void generateMoney (){ System . err . println ( \"This might increase the inflation!\" ); int generated = ThreadLocalRandom . current (). nextInt (); System . out . println ( \"Generated money: $\" + generated + \".00\" ); } } URI Mapping Conventions As Kos don't replace Vert.x's routing mechanism, but only automates its creation, you still can take full advantage of it when using Kos' annotation. You can use: fixed defined paths - with no placeholders or wildcard marks. e.g. /some/path/ paths that begins with something - e.g. /some/path/* paths with variable placeholders - e.g. /catalogue/products/:producttype/:productid/ It is worth notice though that it doesn't support RegEx mapping though. Capturing parameters The following sub-topics will describe how to capture parameters received from the Http Client (e.g. path parameters) in your Rest endpoint method. Vert.x core expects parameters to be either CharSequence or String . To automatically they will be converted into the desired type by the String Converter Mechanism beforehand, making these values available for developers transparently. A few rules apply though: You have to define the placeholder name you are willing to use If you haven't defined the parameter name, the parameter variable name will be used instead If the defined name doesn't match any existing placeholder, an Exception might be thrown If you have defined a complex object for you captured parameter, and no converter has been defined to that given type, an Exception might be thrown. Path Parameters All the matched path placeholders can be easily mapped as parameters in your just created method by using the kos.rest.Path annotation. Kotlin import kos.rest.* @RestApi class MyApi { @GET ( \"/calc/number/:a\" ) fun getMoney ( @Param a : String ) = a @POST ( \"/calc/plus/:a/:b\" ) fun generateMoney ( @Param ( \"a\" ) first : Int , @Param ( \"b\" ) second : Int ) = first + second } Java import kos.rest.* ; @RestApi class MyApi { @GET ( \"/calc/number/:a\" ) Integer getMoney ( @Param Integer a ){ return a ; } @POST ( \"/calc/plus/:a/:b\" ) Integer generateMoney ( @Param ( \"a\" ) Integer first , @Param ( \"b\" ) Integer second ) { return first + second ; } } Query parameters As Vert.x treats query parameters and paths similarly (both being accessible via io.vertx.core.http.HttpServerRequest.getParam(String) ), you can use the same kos.rest.Path to capture query strings as well. Http Headers Similarly to path and query parameters, we can capture headers send by the Http Client by using the kos.rest.Header annotation. Kotlin import kos.rest.* @RestApi class MyApi { @GET ( \"/what-is-my-user-agent\" ) fun whatIsMyUserAgent ( @Param ( \"Content-Type\" ) contentType : String ) = contentType } Java import kos.rest.* ; @RestApi class MyApi { @GET ( \"/what-is-my-user-agent\" ) String whatIsMyUserAgent ( @Param ( \"Content-Type\" ) String contentType ) { return contentType ; } } Capturing the request payload As you might imagine, similarly to capturing other params you can capture the request payload sent in the Http Request's body using an annotation. In this case, it will be kos.rest.Body . Unlike other parameters though, payloads will be converted into an object by the default Serializer Mechanism configured on your application. Kotlin import kos.rest.* @RestApi class MyApi { @POST ( \"/money\" ) fun sendMoney ( @Body request : SendMoneyRequest ) = \" ${ request . to } has received $ ${ request . amount } \" } data class SendMoneyRequest ( val to : String , val amount : Double ) Java import kos.rest.* ; @RestApi class MyApi { @POST ( \"/money\" ) String sendMoney ( @Body SendMoneyRequest request ) { return request . to \" has received $\" + request . amount ; } } class SendMoneyRequest { String to ; Double amount ; // getters and setters }","title":"Rest API"},{"location":"manual/developer/rest-apis/#rest-api","text":"Write down rest API's with Kos is dead simple and, if you've been using Java ecosystem in the last few years you're probably at home. First, be sure you've included kos-annotations in your compilation Class Path, and double-check if you have enabled APT compilation as well (enabled by default only in Java projects). Gradle (kts) compileOnly ( \"io.skullabs.kos:kos-annotations\" ) Maven (pom.kts) provided ( \"io.skullabs.kos:kos-annotations\" ) Maven (pom.xml) <dependency> <groupId> io.skullabs.kos </groupId> <artifactId> kos-annotations </artifactId> <scope> provided </scope> </dependency>","title":"Rest API"},{"location":"manual/developer/rest-apis/#classes-as-api-entrypoints","text":"Kos relies on JVM classes as entrypoint for your APIs. That said, you should identify your class with the kos.rest.RestApi annotation. It will allow Kos to monitor this class for routes. Kotlin import kos.rest.* @RestApi class MyApi { } Java import kos.rest.* ; @RestApi class MyApi { } If your API contains a common root path that could be shared by two or more endpoints, you can set a root path for you API using the RestApi annotation. Kotlin import kos.rest.* @RestApi ( \"/money\" ) class MyApi { } Java import kos.rest.* ; @RestApi ( \"/money\" ) class MyApi { }","title":"Classes as API entrypoints"},{"location":"manual/developer/rest-apis/#exposing-methods-as-rest-endpoints","text":"Out-of-box you can expose any public or package default method as Rest endpoint by using one of the following annotations: kos.rest.GET kos.rest.POST kos.rest.PUT kos.rest.DELETE kos.rest.PATCH","title":"Exposing Methods as Rest endpoints"},{"location":"manual/developer/rest-apis/#defining-uris-for-your-endpoints","text":"Just as kos.rest.RestApi can be used to map a (root) path to an endpoint, the above mentioned annotations can also be used to define a more specific endpoint URI for your methods. In the below example we have two methods exposed as Rest endpoints: MyApi.getMoney will be exposed as GET operation mapped to /money URI. MyApi.getMoreMoney will also be exposed as GET operation, but mapped to /money/double URI. Kotlin import kos.rest.* @RestApi ( \"/money\" ) class MyApi { @GET fun getMoney () = 10 @GET ( \"/double\" ) fun getMoreMoney () = getMoney () * 2 } Java import kos.rest.* ; @RestApi ( \"/money\" ) class MyApi { @GET Integer getMoney (){ return 10 ; } @GET ( \"/double\" ) Integer getMoreMoney (){ return getMoney () * 2 ; } }","title":"Defining URIs for your endpoints"},{"location":"manual/developer/rest-apis/#sending-responses-to-the-http-client","text":"Kos Rest API's will infer the response from the return type defined on your functions: kos.api.Response : this is a special response type bundled in Kos so developers can easily define custom responses to Http Clients. It is particularly useful when you method needs to return different types of Response objects, or different types of Http Status Responses. void : methods that doesn't return a value will make your method API receive the request, perform all the synchronous tasks defined within it and immediately return 204 as default answer. io.vertx.core.Future<?> : by returning Vert.x's Future your Http Clients will wait for the the Future to be completed to receive a response. In case of a success result, the object by the Future instance will be serialized and a successful response will be sent. On the other hand, if your Future holds a failure result, an error message will be sent. Plain Objects: API's that returns plain object will have it's returned object serialized via Default Serializer mechanism and sent as response to your Http Client. How serialization work? Successful responses are automatically serialized through the Default Serializer mechanism. However, in case an exception has been thrown or returned as Future response, the default Exception Handler mechanism will be in charge of converting it into an Http Response. Kotlin import kos.rest.* import io.vertx.core.* import java.util.concurrent.ThreadLocalRandom @RestApi ( \"/money\" ) class MyApi { @GET fun getMoney (): Future < Integer > { val money = Promise . promise () /* * Compute my money. It can be done using any asynchronous operation * as long as you don't block Vert.x's Event Loop. */ return money . future () } @GET ( \"/random\" ) fun getMoreMoney () = return ThreadLocalRandom . current (). nextInt (); @POST fun generateMoney (){ println ( \"This might increase the inflation!\" ) val generated = ThreadLocalRandom . current (). nextInt () println ( \"Generated money: $ $ generated .00\" ); } } Java import kos.rest.* ; import io.vertx.core.* ; import java.util.concurrent.ThreadLocalRandom ; @RestApi ( \"/money\" ) class MyApi { @GET Future < Integer > getMoney (){ Promise < Integer > money = Promise . promise (); /* * Compute my money. It can be done using any asynchronous operation * as long as you don't block Vert.x's Event Loop. */ return money . future (); } @GET ( \"/random\" ) Integer getMoreMoney (){ return ThreadLocalRandom . current (). nextInt (); } @POST void generateMoney (){ System . err . println ( \"This might increase the inflation!\" ); int generated = ThreadLocalRandom . current (). nextInt (); System . out . println ( \"Generated money: $\" + generated + \".00\" ); } }","title":"Sending responses to the Http Client"},{"location":"manual/developer/rest-apis/#uri-mapping-conventions","text":"As Kos don't replace Vert.x's routing mechanism, but only automates its creation, you still can take full advantage of it when using Kos' annotation. You can use: fixed defined paths - with no placeholders or wildcard marks. e.g. /some/path/ paths that begins with something - e.g. /some/path/* paths with variable placeholders - e.g. /catalogue/products/:producttype/:productid/ It is worth notice though that it doesn't support RegEx mapping though.","title":"URI Mapping Conventions"},{"location":"manual/developer/rest-apis/#capturing-parameters","text":"The following sub-topics will describe how to capture parameters received from the Http Client (e.g. path parameters) in your Rest endpoint method. Vert.x core expects parameters to be either CharSequence or String . To automatically they will be converted into the desired type by the String Converter Mechanism beforehand, making these values available for developers transparently. A few rules apply though: You have to define the placeholder name you are willing to use If you haven't defined the parameter name, the parameter variable name will be used instead If the defined name doesn't match any existing placeholder, an Exception might be thrown If you have defined a complex object for you captured parameter, and no converter has been defined to that given type, an Exception might be thrown.","title":"Capturing parameters"},{"location":"manual/developer/rest-apis/#path-parameters","text":"All the matched path placeholders can be easily mapped as parameters in your just created method by using the kos.rest.Path annotation. Kotlin import kos.rest.* @RestApi class MyApi { @GET ( \"/calc/number/:a\" ) fun getMoney ( @Param a : String ) = a @POST ( \"/calc/plus/:a/:b\" ) fun generateMoney ( @Param ( \"a\" ) first : Int , @Param ( \"b\" ) second : Int ) = first + second } Java import kos.rest.* ; @RestApi class MyApi { @GET ( \"/calc/number/:a\" ) Integer getMoney ( @Param Integer a ){ return a ; } @POST ( \"/calc/plus/:a/:b\" ) Integer generateMoney ( @Param ( \"a\" ) Integer first , @Param ( \"b\" ) Integer second ) { return first + second ; } }","title":"Path Parameters"},{"location":"manual/developer/rest-apis/#query-parameters","text":"As Vert.x treats query parameters and paths similarly (both being accessible via io.vertx.core.http.HttpServerRequest.getParam(String) ), you can use the same kos.rest.Path to capture query strings as well.","title":"Query parameters"},{"location":"manual/developer/rest-apis/#http-headers","text":"Similarly to path and query parameters, we can capture headers send by the Http Client by using the kos.rest.Header annotation. Kotlin import kos.rest.* @RestApi class MyApi { @GET ( \"/what-is-my-user-agent\" ) fun whatIsMyUserAgent ( @Param ( \"Content-Type\" ) contentType : String ) = contentType } Java import kos.rest.* ; @RestApi class MyApi { @GET ( \"/what-is-my-user-agent\" ) String whatIsMyUserAgent ( @Param ( \"Content-Type\" ) String contentType ) { return contentType ; } }","title":"Http Headers"},{"location":"manual/developer/rest-apis/#capturing-the-request-payload","text":"As you might imagine, similarly to capturing other params you can capture the request payload sent in the Http Request's body using an annotation. In this case, it will be kos.rest.Body . Unlike other parameters though, payloads will be converted into an object by the default Serializer Mechanism configured on your application. Kotlin import kos.rest.* @RestApi class MyApi { @POST ( \"/money\" ) fun sendMoney ( @Body request : SendMoneyRequest ) = \" ${ request . to } has received $ ${ request . amount } \" } data class SendMoneyRequest ( val to : String , val amount : Double ) Java import kos.rest.* ; @RestApi class MyApi { @POST ( \"/money\" ) String sendMoney ( @Body SendMoneyRequest request ) { return request . to \" has received $\" + request . amount ; } } class SendMoneyRequest { String to ; Double amount ; // getters and setters }","title":"Capturing the request payload"},{"location":"manual/developer/rest-clients/","text":"Rest Clients Write down rest clients is usually a task most people don't like to do, especially in the JVM ecosystem. We have several Http abstractions and implementations, each of them with different dependency stack. Vert.x team introduced a web client API on their vertx-web module, which is managed by vertx-core connection pool for optimal resource utilization. By borrowing a few ideas from Netflix Feign and other well known open source frameworks, Kos provides a simple API to create Rest Clients that takes advantage of the well crafted vertx-web module. It is behaves similarly to the Rest API: it uses the same annotations as the Rest Api to map endpoints to methods the same applies when mapping path parameters , query parameters or headers to method parameters it also uses the same Body annotation to serialize and send request payloads Interfaces as API entrypoint The biggest difference lies on the fact that you don't write concrete classes to define your Rest Clients, you write interfaces. You also have to annotate them with kos.rest.RestClient instead of the kos.core.RestApi one. Kotlin import kos.rest.* @RestClient ( \"/calc\" ) interface CalculatorApiClient { @GET ( \"/plus/:a/:b\" ) fun plus ( @Param a : Int , @Param b : Int ): Future < Int > @GET ( \"/minus/:a/:b\" ) fun minus ( @Param a : Int , @Param b : Int ): Future < Int > } Java import kos.rest.* ; @RestClient ( \"/calc\" ) interface CalculatorApiClient { @GET ( \"/plus/:a/:b\" ) Future < Int > plus ( @Param Integer a , @Param Integer b ); @GET ( \"/minus/:a/:b\" ) Future < Int > minus ( @Param Integer a , @Param Integer b ); } Consuming responses to the Http Server Kos Rest Client's will infer the response from the return type defined on your functions: void : methods that doesn't return a value will make the call to the desired API in a fire-and-forget fashion, completely ignoring the response received by the server. io.vertx.core.Future<?> : Http Clients will hold the received response in a Future object allowing you to handle the response asynchronously on your first convenience. As you probably notice, Http Clients never blocks the event loop. This comes with a few restrictions though: You have no automated mechanism to map failures into objects In case of Http responses other than 2xx an Exception ( UnexpectedRestClientResponse ) will be set as future Response allowing you to manually handle the unexpected behavior. Instantiating your Rest Client As the Rest Client API only takes care of mapping endpoints it doesn't know anything else about your client. By using the RestClientFactory.instantiate(RestClientConfiguration, T) method, you can define how it will work, which URL should be used to reach the server, how authentication might work, etc. Kotlin import injector.* import kos.core.client.RestClientConfiguration @Singleton class CalculatorApiClientConfiguration ( val restClientFactory : RestClientFactory ){ @Produces fun produceClient (): CalculatorApiClient { val baseUrl = \"https://empty.url\" val restConf = RestClientConfiguration . withUrl ( baseUrl ). build () return restClientFactory . instantiate ( restConf , CalculatorApiClient :: class . java ) } } @RestApi class MyApi ( val calculator : CalculatorApiClient ) { @GET ( \"/calc/2/plus/2\" ) fun calculateTwoPlusTwo () = calculator . plus ( 2 , 2 ) } Java import injector.* ; import io.vertx.core.Future ; import kos.core.client.RestClientConfiguration ; @Singleton public class CalculatorApiClientConfiguration { final RestClientFactory restClientFactory ; public CalculatorApiClientConfiguration ( RestClientFactory restClientFactory ) { this . restClientFactory = restClientFactory ; } @Produces CalculatorApiClient produceClient () { val baseUrl = \"https://empty.url\" ; val restConf = RestClientConfiguration . withUrl ( baseUrl ). build (); return restClientFactory . instantiate ( restConf , CalculatorApiClient . java ); } } @RestApi public class MyApi { final CalculatorApiClient calculator ; public MyApi ( CalculatorApiClient calculator ) { this . calculator = calculator ; } @GET ( \"/calc/2/plus/2\" ) Future < Integer > calculateTwoPlusTwo () { return calculator . plus ( 2 , 2 ); } } The example above will use Injector to produce an instance of our client whenever one needs to be injected in our controller. As our controller is a @Singleton , only one instance will be created. Info For optimal resource usage, you might want to cache the created client. RestClientConfiguration Here are the main methods of the RestClientConfiguration class: withUrl : Set the base URL withHeaders : Set custom headers withRestClientSerializer : Define how successful responses will be serialized withStringConverter : Allow customizing how parameters and headers will be converted from Objects to String withClient : Allow defining a custom Vert.x WebClient instance - useful when we need to perform an advanced client configuration.","title":"Rest Clients"},{"location":"manual/developer/rest-clients/#rest-clients","text":"Write down rest clients is usually a task most people don't like to do, especially in the JVM ecosystem. We have several Http abstractions and implementations, each of them with different dependency stack. Vert.x team introduced a web client API on their vertx-web module, which is managed by vertx-core connection pool for optimal resource utilization. By borrowing a few ideas from Netflix Feign and other well known open source frameworks, Kos provides a simple API to create Rest Clients that takes advantage of the well crafted vertx-web module. It is behaves similarly to the Rest API: it uses the same annotations as the Rest Api to map endpoints to methods the same applies when mapping path parameters , query parameters or headers to method parameters it also uses the same Body annotation to serialize and send request payloads","title":"Rest Clients"},{"location":"manual/developer/rest-clients/#interfaces-as-api-entrypoint","text":"The biggest difference lies on the fact that you don't write concrete classes to define your Rest Clients, you write interfaces. You also have to annotate them with kos.rest.RestClient instead of the kos.core.RestApi one. Kotlin import kos.rest.* @RestClient ( \"/calc\" ) interface CalculatorApiClient { @GET ( \"/plus/:a/:b\" ) fun plus ( @Param a : Int , @Param b : Int ): Future < Int > @GET ( \"/minus/:a/:b\" ) fun minus ( @Param a : Int , @Param b : Int ): Future < Int > } Java import kos.rest.* ; @RestClient ( \"/calc\" ) interface CalculatorApiClient { @GET ( \"/plus/:a/:b\" ) Future < Int > plus ( @Param Integer a , @Param Integer b ); @GET ( \"/minus/:a/:b\" ) Future < Int > minus ( @Param Integer a , @Param Integer b ); }","title":"Interfaces as API entrypoint"},{"location":"manual/developer/rest-clients/#consuming-responses-to-the-http-server","text":"Kos Rest Client's will infer the response from the return type defined on your functions: void : methods that doesn't return a value will make the call to the desired API in a fire-and-forget fashion, completely ignoring the response received by the server. io.vertx.core.Future<?> : Http Clients will hold the received response in a Future object allowing you to handle the response asynchronously on your first convenience. As you probably notice, Http Clients never blocks the event loop. This comes with a few restrictions though: You have no automated mechanism to map failures into objects In case of Http responses other than 2xx an Exception ( UnexpectedRestClientResponse ) will be set as future Response allowing you to manually handle the unexpected behavior.","title":"Consuming responses to the Http Server"},{"location":"manual/developer/rest-clients/#instantiating-your-rest-client","text":"As the Rest Client API only takes care of mapping endpoints it doesn't know anything else about your client. By using the RestClientFactory.instantiate(RestClientConfiguration, T) method, you can define how it will work, which URL should be used to reach the server, how authentication might work, etc. Kotlin import injector.* import kos.core.client.RestClientConfiguration @Singleton class CalculatorApiClientConfiguration ( val restClientFactory : RestClientFactory ){ @Produces fun produceClient (): CalculatorApiClient { val baseUrl = \"https://empty.url\" val restConf = RestClientConfiguration . withUrl ( baseUrl ). build () return restClientFactory . instantiate ( restConf , CalculatorApiClient :: class . java ) } } @RestApi class MyApi ( val calculator : CalculatorApiClient ) { @GET ( \"/calc/2/plus/2\" ) fun calculateTwoPlusTwo () = calculator . plus ( 2 , 2 ) } Java import injector.* ; import io.vertx.core.Future ; import kos.core.client.RestClientConfiguration ; @Singleton public class CalculatorApiClientConfiguration { final RestClientFactory restClientFactory ; public CalculatorApiClientConfiguration ( RestClientFactory restClientFactory ) { this . restClientFactory = restClientFactory ; } @Produces CalculatorApiClient produceClient () { val baseUrl = \"https://empty.url\" ; val restConf = RestClientConfiguration . withUrl ( baseUrl ). build (); return restClientFactory . instantiate ( restConf , CalculatorApiClient . java ); } } @RestApi public class MyApi { final CalculatorApiClient calculator ; public MyApi ( CalculatorApiClient calculator ) { this . calculator = calculator ; } @GET ( \"/calc/2/plus/2\" ) Future < Integer > calculateTwoPlusTwo () { return calculator . plus ( 2 , 2 ); } } The example above will use Injector to produce an instance of our client whenever one needs to be injected in our controller. As our controller is a @Singleton , only one instance will be created. Info For optimal resource usage, you might want to cache the created client.","title":"Instantiating your Rest Client"},{"location":"manual/developer/rest-clients/#restclientconfiguration","text":"Here are the main methods of the RestClientConfiguration class: withUrl : Set the base URL withHeaders : Set custom headers withRestClientSerializer : Define how successful responses will be serialized withStringConverter : Allow customizing how parameters and headers will be converted from Objects to String withClient : Allow defining a custom Vert.x WebClient instance - useful when we need to perform an advanced client configuration.","title":"RestClientConfiguration"}]}