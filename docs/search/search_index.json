{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview Kos is small layer over Vert.x to leverage web developers productivity by providing them a zero-overhead and minimalistic API. It was carefully designed to not hide from developers how the software works underneath. Kos also embrace Vert.x philosophy and doesn't enforce developers to follow opinionated conventions - as all of them are optional - but provide them an easy and transparent mechanism to avoid repetitive tasks. Features a reflection-free layer over Vert.x web API a simplified way to spin up the web server automatically deploy Vert.x Verticles automatically load vertx-config configuration introduce customization entries for sensible mechanisms (like serializers) Motivation Vert.x shines in the JVM ecosystem as blistering fast toolkit to build scalable and reliable web applications. Aside of its well crafted non-blocking event-loop and a versatile multi-propose web layer, it comes with a set of reactive tools and non-blocking drivers that leverages the application performance to another level. It comes though with a trade-off as some may see it as niche solution due to its low-level API. According to a Stack Overflow survey almost 60% of the developers identify themselves as backend-developers. It's known that, aside from a few edge-cases, backend-developers are mostly focused on delivery new features to increase the aggregated value of a program, letting the of perform low-level tuning to software architects and scientists , squeezing bits and bytes whenever possible to reduce cost or improve the user usage experience. Steady, repeatable and predictable (a.k.a. boring ) routine directly conflicts with the developer's desire of learning something new - or arguably more fun. You can see traits of this behaviour everywhere, specially regarding sluggish performance of frameworks, lack of innovative approaches and old-minded communities. Keeping a relevant role in the developers routine by providing an updated and open-minded development alternative, whilst ensuring developers productivity, is definitely a hard task. By keeping Vert.x as foundation of his existence, Kos aims to fill this gap between by encouraging the development of high-performance applications with less hassle. Philosophy These are the principles that guides Kos development: Keep things simple but flexible . Conventions are Pareto-friendly, therefore, doesn't solve all the problems. Kos will simplify things whenever possible, but developers are always free to switch back vanilla Vert.x . Keep it fast . Simplifying repetitive routines should never hurt the software performance. Vert.x as first-class citizen . While Kos wraps some of Vert.x API, it encourages developers to make use of it whenever needed. Kos wrappers always returns the Vert.x equivalent for further usage. Never block the event loop . You may have heard about that before, but it worth to mention you should never block the event-loop. History This project was started between late 2018 and early 2019 on an attempt to provide Sizebay a simple API to replace their previous undertow-based microservices framework. The idea came up when we had the necessity to include more developers on the team and we wanted to avoid them to talk directly to Undertow and XNIO as they was designed as low-level APIs. The project name kos (pronounces like coosh) came from Norwegian and is a word used to describe all the things that make you feel cozy and warm inside. License Kos is release under Apache License 2 terms.","title":"Overview"},{"location":"#overview","text":"Kos is small layer over Vert.x to leverage web developers productivity by providing them a zero-overhead and minimalistic API. It was carefully designed to not hide from developers how the software works underneath. Kos also embrace Vert.x philosophy and doesn't enforce developers to follow opinionated conventions - as all of them are optional - but provide them an easy and transparent mechanism to avoid repetitive tasks.","title":"Overview"},{"location":"#features","text":"a reflection-free layer over Vert.x web API a simplified way to spin up the web server automatically deploy Vert.x Verticles automatically load vertx-config configuration introduce customization entries for sensible mechanisms (like serializers)","title":"Features"},{"location":"#motivation","text":"Vert.x shines in the JVM ecosystem as blistering fast toolkit to build scalable and reliable web applications. Aside of its well crafted non-blocking event-loop and a versatile multi-propose web layer, it comes with a set of reactive tools and non-blocking drivers that leverages the application performance to another level. It comes though with a trade-off as some may see it as niche solution due to its low-level API. According to a Stack Overflow survey almost 60% of the developers identify themselves as backend-developers. It's known that, aside from a few edge-cases, backend-developers are mostly focused on delivery new features to increase the aggregated value of a program, letting the of perform low-level tuning to software architects and scientists , squeezing bits and bytes whenever possible to reduce cost or improve the user usage experience. Steady, repeatable and predictable (a.k.a. boring ) routine directly conflicts with the developer's desire of learning something new - or arguably more fun. You can see traits of this behaviour everywhere, specially regarding sluggish performance of frameworks, lack of innovative approaches and old-minded communities. Keeping a relevant role in the developers routine by providing an updated and open-minded development alternative, whilst ensuring developers productivity, is definitely a hard task. By keeping Vert.x as foundation of his existence, Kos aims to fill this gap between by encouraging the development of high-performance applications with less hassle.","title":"Motivation"},{"location":"#philosophy","text":"These are the principles that guides Kos development: Keep things simple but flexible . Conventions are Pareto-friendly, therefore, doesn't solve all the problems. Kos will simplify things whenever possible, but developers are always free to switch back vanilla Vert.x . Keep it fast . Simplifying repetitive routines should never hurt the software performance. Vert.x as first-class citizen . While Kos wraps some of Vert.x API, it encourages developers to make use of it whenever needed. Kos wrappers always returns the Vert.x equivalent for further usage. Never block the event loop . You may have heard about that before, but it worth to mention you should never block the event-loop.","title":"Philosophy"},{"location":"#history","text":"This project was started between late 2018 and early 2019 on an attempt to provide Sizebay a simple API to replace their previous undertow-based microservices framework. The idea came up when we had the necessity to include more developers on the team and we wanted to avoid them to talk directly to Undertow and XNIO as they was designed as low-level APIs. The project name kos (pronounces like coosh) came from Norwegian and is a word used to describe all the things that make you feel cozy and warm inside.","title":"History"},{"location":"#license","text":"Kos is release under Apache License 2 terms.","title":"License"},{"location":"01-getting-started/","text":"Getting Started Info Don't want to follow the following steps by yourself? What about downloading a blueprint project that you can change according to your needs? Gradle+Kotlin Project [ Download ] [ Source Code ] Kos is mostly written in Java and carefully designed to be easily integrated other JVM languages like Kotlin and Scala. To import Kos you should include the following libraries on your project. Gradle (kts) dependencies { // Import the Bill of Materials implementation ( platform ( \"io.skullabs.kos:kos-bom: ${ version_kos } \" )) implementation ( \"io.skullabs.kos:kos-core\" ) compileOnly ( \"io.skullabs.kos:kos-annotations\" ) } Maven (pom.kts) dependencyManagement { dependencies { // Import the Bill of Materials import ( \"io.skullabs.kos:kos-bom: ${ kosVersion } \" ) } } dependencies { // Kos Dependencies compile ( \"io.skullabs.kos:kos-core\" ) compile ( \"io.skullabs.kos:kos-injector\" ) provided ( \"io.skullabs.kos:kos-annotations\" ) } Maven (pom.xml) <dependencyManagement> <dependencies> <!-- Import the Bill of Materials --> <dependency> <groupId> io.skullabs.kos </groupId> <artifactId> kos-bom </artifactId> <version> ${version_kos} </version> <type> pom </type> <scope> import </scope> </dependency> </dependencies> </dependencyManagement> <dependencies> <dependency> <groupId> io.skullabs.kos </groupId> <artifactId> kos-core </artifactId> </dependency> <dependency> <groupId> io.skullabs.kos </groupId> <artifactId> kos-annotations </artifactId> </dependency> </dependency> Now let's create a simple HelloWorld API. Kotlin @Path ( \"hello\" ) class HelloWorldApi { @GET ( \"world\" ) fun sayHello () = \"Hello World\" } Java @Path ( \"hello\" ) class HelloWorldApi { @GET ( \"world\" ) String sayHello () { return \"Hello World\" ; } } Finally, we have to bundle all dependencies together and generate a runnable jar with them. Gradle (kts) // You can use either Shadow or VertX plugin to generate a fat jar // We've picked VertX in this example plugins { id ( \"io.vertx.vertx-plugin\" ) version \"1.2.0\" } vertx { launcher = launcherClass } Maven (pom.kts) plugins { plugin ( \"org.apache.maven.plugins:maven-shade-plugin:3.2.0\" ) { executions { execution ( id = \"default-package\" , phase = \"package\" , goals = listOf ( \"shade\" )) } configuration { \"createDependencyReducedPom\" to true \"dependencyReducedPomLocation\" to \"\\ ${ project . build . directory } /pom-reduced.xml\" \"transformers\" { \"org.apache.maven.plugins.shade.resource.ServicesResourceTransformer\" {} \"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\" { \"manifestEntries\" { \"Main-Class\" to launcherClass } } } } } } Maven (pom.xml) <plugin> <artifactId> maven-shade-plugin </artifactId> <version> 3.2.0 </version> <executions> <execution> <id> default-package </id> <phase> package </phase> <goals> <goal> shade </goal> </goals> <configuration> <createDependencyReducedPom> true </createDependencyReducedPom> <dependencyReducedPomLocation> ${project.build.directory}/pom-reduced.xml </dependencyReducedPomLocation> <transformers> <org.apache.maven.plugins.shade.resource.ServicesResourceTransformer /> <org.apache.maven.plugins.shade.resource.ManifestResourceTransformer> <manifestEntries> <Main-Class> kos.core.Launcher </Main-Class> </manifestEntries> </org.apache.maven.plugins.shade.resource.ManifestResourceTransformer> </transformers> </configuration> </execution> </executions> </plugin> Voila ! Our first Kos software is ready. Let's run it? Gradle $ java -jar build/libs/my-kos-app-all.jar Maven $ java -jar target/my-kos-app.jar","title":"Getting Started"},{"location":"01-getting-started/#getting-started","text":"Info Don't want to follow the following steps by yourself? What about downloading a blueprint project that you can change according to your needs? Gradle+Kotlin Project [ Download ] [ Source Code ] Kos is mostly written in Java and carefully designed to be easily integrated other JVM languages like Kotlin and Scala. To import Kos you should include the following libraries on your project. Gradle (kts) dependencies { // Import the Bill of Materials implementation ( platform ( \"io.skullabs.kos:kos-bom: ${ version_kos } \" )) implementation ( \"io.skullabs.kos:kos-core\" ) compileOnly ( \"io.skullabs.kos:kos-annotations\" ) } Maven (pom.kts) dependencyManagement { dependencies { // Import the Bill of Materials import ( \"io.skullabs.kos:kos-bom: ${ kosVersion } \" ) } } dependencies { // Kos Dependencies compile ( \"io.skullabs.kos:kos-core\" ) compile ( \"io.skullabs.kos:kos-injector\" ) provided ( \"io.skullabs.kos:kos-annotations\" ) } Maven (pom.xml) <dependencyManagement> <dependencies> <!-- Import the Bill of Materials --> <dependency> <groupId> io.skullabs.kos </groupId> <artifactId> kos-bom </artifactId> <version> ${version_kos} </version> <type> pom </type> <scope> import </scope> </dependency> </dependencies> </dependencyManagement> <dependencies> <dependency> <groupId> io.skullabs.kos </groupId> <artifactId> kos-core </artifactId> </dependency> <dependency> <groupId> io.skullabs.kos </groupId> <artifactId> kos-annotations </artifactId> </dependency> </dependency> Now let's create a simple HelloWorld API. Kotlin @Path ( \"hello\" ) class HelloWorldApi { @GET ( \"world\" ) fun sayHello () = \"Hello World\" } Java @Path ( \"hello\" ) class HelloWorldApi { @GET ( \"world\" ) String sayHello () { return \"Hello World\" ; } } Finally, we have to bundle all dependencies together and generate a runnable jar with them. Gradle (kts) // You can use either Shadow or VertX plugin to generate a fat jar // We've picked VertX in this example plugins { id ( \"io.vertx.vertx-plugin\" ) version \"1.2.0\" } vertx { launcher = launcherClass } Maven (pom.kts) plugins { plugin ( \"org.apache.maven.plugins:maven-shade-plugin:3.2.0\" ) { executions { execution ( id = \"default-package\" , phase = \"package\" , goals = listOf ( \"shade\" )) } configuration { \"createDependencyReducedPom\" to true \"dependencyReducedPomLocation\" to \"\\ ${ project . build . directory } /pom-reduced.xml\" \"transformers\" { \"org.apache.maven.plugins.shade.resource.ServicesResourceTransformer\" {} \"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\" { \"manifestEntries\" { \"Main-Class\" to launcherClass } } } } } } Maven (pom.xml) <plugin> <artifactId> maven-shade-plugin </artifactId> <version> 3.2.0 </version> <executions> <execution> <id> default-package </id> <phase> package </phase> <goals> <goal> shade </goal> </goals> <configuration> <createDependencyReducedPom> true </createDependencyReducedPom> <dependencyReducedPomLocation> ${project.build.directory}/pom-reduced.xml </dependencyReducedPomLocation> <transformers> <org.apache.maven.plugins.shade.resource.ServicesResourceTransformer /> <org.apache.maven.plugins.shade.resource.ManifestResourceTransformer> <manifestEntries> <Main-Class> kos.core.Launcher </Main-Class> </manifestEntries> </org.apache.maven.plugins.shade.resource.ManifestResourceTransformer> </transformers> </configuration> </execution> </executions> </plugin> Voila ! Our first Kos software is ready. Let's run it? Gradle $ java -jar build/libs/my-kos-app-all.jar Maven $ java -jar target/my-kos-app.jar","title":"Getting Started"},{"location":"02-rest-apis/","text":"Rest APIs Write down rest API's with Kos is dead simple and, if you've been using Java ecosystem in the last few years you're probably at home. First, be sure you've included kos-annotations in your compilation Class Path, and double-check if you have enabled APT compilation as well (enabled by default only in Java projects). Gradle (kts) compileOnly ( \"io.skullabs.kos:kos-annotations\" ) Maven (pom.kts) provided ( \"io.skullabs.kos:kos-annotations\" ) Maven (pom.xml) <dependency> <groupId> io.skullabs.kos </groupId> <artifactId> kos-annotations </artifactId> <scope> provided </scope> </dependency> Classes as API entrypoints Kos relies on JVM classes as entrypoint for your APIs. That said, you should identify your class with the kos.rest.RestApi annotation. It will allow Kos to monitor this class for routes. Kotlin import kos.rest.* @RestApi class MyApi { } Java import kos.rest.* ; @RestApi class MyApi { } If your API contains a common root path that would be shared by two or more endpoints, you can set a root path for you API using the RestApi annotation. Kotlin import kos.rest.* @RestApi ( \"/money\" ) class MyApi { } Java import kos.rest.* ; @RestApi ( \"/money\" ) class MyApi { } Info By default kos-annotation module will include your class in the Implementation Loader life cycle, making it automatically managed by the default Implementation Loader mechanism you've configured. For further details, please proceed to this topic. Exposing Methods as Rest endpoints Out-of-box you can expose any public or package default method as Rest endpoint by using one of the following annotations: kos.rest.GET kos.rest.POST kos.rest.PUT kos.rest.DELETE kos.rest.PATCH Defining URIs for your endpoints Just as kos.rest.RestApi can be used to map a (root) path to an endpoint, the above mentioned annotations can also be used to define a more specific endpoint URI for your methods. In the below example we have two methods exposed as Rest endpoints: MyApi.getMoney will be exposed as GET operation mapped to /money URI. MyApi.getMoreMoney will also be exposed as GET operation, but mapped to /money/double URI. Kotlin import kos.rest.* @RestApi ( \"/money\" ) class MyApi { @GET fun getMoney () = 10 @GET ( \"/double\" ) fun getMoreMoney () = getMoney () * 2 } Java import kos.rest.* ; @RestApi ( \"/money\" ) class MyApi { @GET Integer getMoney (){ return 10 ; } @GET ( \"/double\" ) Integer getMoreMoney (){ return getMoney () * 2 ; } } Sending responses to the Http Client Kos Rest API's will infer the response from the return type defined on your functions: kos.api.Response : this is a special response type bundled in Kos so developers can easily define custom responses to Http Clients. It is particularly useful when you method needs to return different types of Response objects, or different types of Http Status Responses. void : methods that doesn't return a value will make your method API receive the request, perform all the synchronous tasks defined within it and immediately return 204 as default answer. io.vertx.core.Future<?> : by returning Vert.x's Future your Http Clients will be waiting for the the Future to be resolved in order to receive a response. The object defined as Future's result will be later serialized using the Default Serializer mechanism. On the other hand, if your Future holds a failure result, an error message will be sent using the default Exception Handler mechanism defined on your application. Plain Objects: API's that returns plain object will have it's returned object serialized via Default Serializer mechanism and sent as response to your Http Client. Kotlin import kos.rest.* import io.vertx.core.* import java.util.concurrent.ThreadLocalRandom @RestApi ( \"/money\" ) class MyApi { @GET fun getMoney (): Future < Integer > { val money = Promise . promise () /* * Compute my money. It can be done using any asynchronous operation * as long as you don't block Vert.x's Event Loop. */ return money . future () } @GET ( \"/random\" ) fun getMoreMoney () = return ThreadLocalRandom . current (). nextInt (); @POST fun generateMoney (){ println ( \"This might increase the inflation!\" ) val generated = ThreadLocalRandom . current (). nextInt () println ( \"Generated money: $ $ generated .00\" ); } } Java import kos.rest.* ; import io.vertx.core.* ; import java.util.concurrent.ThreadLocalRandom ; @RestApi ( \"/money\" ) class MyApi { @GET Future < Integer > getMoney (){ Promise < Integer > money = Promise . promise (); /* * Compute my money. It can be done using any asynchronous operation * as long as you don't block Vert.x's Event Loop. */ return money . future (); } @GET ( \"/random\" ) Integer getMoreMoney (){ return ThreadLocalRandom . current (). nextInt (); } @POST void generateMoney (){ System . err . println ( \"This might increase the inflation!\" ); int generated = ThreadLocalRandom . current (). nextInt (); System . out . println ( \"Generated money: $\" + generated + \".00\" ); } } URI Mapping Conventions As Kos don't replace Vert.x's routing mechanism, but only automates its creation, you still can take full advantage of it when using Kos' annotation. You can use: fixed defined paths - with no placeholders or wildcard marks. e.g. /some/path/ paths that begins with something - e.g. /some/path/* paths with variable placeholders - e.g. /catalogue/products/:producttype/:productid/ It is worth notice though that it doesn't support RegEx mapping though. Capturing parameters The following sub-topics will describe how to capture parameters received from the Http Client (e.g. path parameters) in your Rest endpoint method. As parameters are received as either CharSequence or String by the Vert.x core, they will be converted into the desired type by the String Converter Mechanism beforehand, making these values available for developers transparently. A few rules apply though: You have to define the placeholder name you are willing to use If you haven't defined the parameter name, the parameter variable name will be used instead If the defined name doesn't match any existing placeholder, an Exception might be thrown If you have defined a complex object for you captured parameter, and no converted has been defined to that given type, an Exception might be thrown Path Parameters All the matched path placeholders can be easily mapped as parameters in your just created method by using the kos.rest.Path annotation. Kotlin import kos.rest.* @RestApi class MyApi { @GET ( \"/calc/number/:a\" ) fun getMoney ( @Param a : String ) = a @POST ( \"/calc/plus/:a/:b\" ) fun generateMoney ( @Param ( \"a\" ) first : Int , @Param ( \"b\" ) second : Int ) = first + second } Java import kos.rest.* ; @RestApi class MyApi { @GET ( \"/calc/number/:a\" ) Integer getMoney ( @Param Integer a ){ return a ; } @POST ( \"/calc/plus/:a/:b\" ) Integer generateMoney ( @Param ( \"a\" ) Integer first , @Param ( \"b\" ) Integer second ) { return first + second ; } } Query parameters As Vert.x treats query parameters and paths similarly (both being accessible via io.vertx.core.http.HttpServerRequest.getParam(String) ), you can use the same kos.rest.Path to capture query strings as well. Http Headers Similarly to path and query parameters, we can capture headers send by the Http Client by using the kos.rest.Header annotation. Kotlin import kos.rest.* @RestApi class MyApi { @GET ( \"/what-is-my-user-agent\" ) fun whatIsMyUserAgent ( @Param ( \"Content-Type\" ) contentType : String ) = contentType } Java import kos.rest.* ; @RestApi class MyApi { @GET ( \"/what-is-my-user-agent\" ) String whatIsMyUserAgent ( @Param ( \"Content-Type\" ) String contentType ) { return contentType ; } } Capturing the request payload As you might imagine, similarly to capturing other params you can capture the request payload sent in the Http Request's body using an annotation. In this case, it will be kos.rest.Body . Unlike other parameters though, payloads will be converted into an object by the default Serializer Mechanism configured on your application. Kotlin import kos.rest.* @RestApi class MyApi { @POST ( \"/money\" ) fun sendMoney ( @Body request : SendMoneyRequest ) = \" ${ request . to } has received $ ${ request . amount } \" } data class SendMoneyRequest ( val to : String , val amount : Double ) Java import kos.rest.* ; @RestApi class MyApi { @POST ( \"/money\" ) String sendMoney ( @Body SendMoneyRequest request ) { return request . to \" has received $\" + request . amount ; } } class SendMoneyRequest { String to ; Double amount ; // getters and setters }","title":"Rest APIs"},{"location":"02-rest-apis/#rest-apis","text":"Write down rest API's with Kos is dead simple and, if you've been using Java ecosystem in the last few years you're probably at home. First, be sure you've included kos-annotations in your compilation Class Path, and double-check if you have enabled APT compilation as well (enabled by default only in Java projects). Gradle (kts) compileOnly ( \"io.skullabs.kos:kos-annotations\" ) Maven (pom.kts) provided ( \"io.skullabs.kos:kos-annotations\" ) Maven (pom.xml) <dependency> <groupId> io.skullabs.kos </groupId> <artifactId> kos-annotations </artifactId> <scope> provided </scope> </dependency>","title":"Rest APIs"},{"location":"02-rest-apis/#classes-as-api-entrypoints","text":"Kos relies on JVM classes as entrypoint for your APIs. That said, you should identify your class with the kos.rest.RestApi annotation. It will allow Kos to monitor this class for routes. Kotlin import kos.rest.* @RestApi class MyApi { } Java import kos.rest.* ; @RestApi class MyApi { } If your API contains a common root path that would be shared by two or more endpoints, you can set a root path for you API using the RestApi annotation. Kotlin import kos.rest.* @RestApi ( \"/money\" ) class MyApi { } Java import kos.rest.* ; @RestApi ( \"/money\" ) class MyApi { } Info By default kos-annotation module will include your class in the Implementation Loader life cycle, making it automatically managed by the default Implementation Loader mechanism you've configured. For further details, please proceed to this topic.","title":"Classes as API entrypoints"},{"location":"02-rest-apis/#exposing-methods-as-rest-endpoints","text":"Out-of-box you can expose any public or package default method as Rest endpoint by using one of the following annotations: kos.rest.GET kos.rest.POST kos.rest.PUT kos.rest.DELETE kos.rest.PATCH","title":"Exposing Methods as Rest endpoints"},{"location":"02-rest-apis/#defining-uris-for-your-endpoints","text":"Just as kos.rest.RestApi can be used to map a (root) path to an endpoint, the above mentioned annotations can also be used to define a more specific endpoint URI for your methods. In the below example we have two methods exposed as Rest endpoints: MyApi.getMoney will be exposed as GET operation mapped to /money URI. MyApi.getMoreMoney will also be exposed as GET operation, but mapped to /money/double URI. Kotlin import kos.rest.* @RestApi ( \"/money\" ) class MyApi { @GET fun getMoney () = 10 @GET ( \"/double\" ) fun getMoreMoney () = getMoney () * 2 } Java import kos.rest.* ; @RestApi ( \"/money\" ) class MyApi { @GET Integer getMoney (){ return 10 ; } @GET ( \"/double\" ) Integer getMoreMoney (){ return getMoney () * 2 ; } }","title":"Defining URIs for your endpoints"},{"location":"02-rest-apis/#sending-responses-to-the-http-client","text":"Kos Rest API's will infer the response from the return type defined on your functions: kos.api.Response : this is a special response type bundled in Kos so developers can easily define custom responses to Http Clients. It is particularly useful when you method needs to return different types of Response objects, or different types of Http Status Responses. void : methods that doesn't return a value will make your method API receive the request, perform all the synchronous tasks defined within it and immediately return 204 as default answer. io.vertx.core.Future<?> : by returning Vert.x's Future your Http Clients will be waiting for the the Future to be resolved in order to receive a response. The object defined as Future's result will be later serialized using the Default Serializer mechanism. On the other hand, if your Future holds a failure result, an error message will be sent using the default Exception Handler mechanism defined on your application. Plain Objects: API's that returns plain object will have it's returned object serialized via Default Serializer mechanism and sent as response to your Http Client. Kotlin import kos.rest.* import io.vertx.core.* import java.util.concurrent.ThreadLocalRandom @RestApi ( \"/money\" ) class MyApi { @GET fun getMoney (): Future < Integer > { val money = Promise . promise () /* * Compute my money. It can be done using any asynchronous operation * as long as you don't block Vert.x's Event Loop. */ return money . future () } @GET ( \"/random\" ) fun getMoreMoney () = return ThreadLocalRandom . current (). nextInt (); @POST fun generateMoney (){ println ( \"This might increase the inflation!\" ) val generated = ThreadLocalRandom . current (). nextInt () println ( \"Generated money: $ $ generated .00\" ); } } Java import kos.rest.* ; import io.vertx.core.* ; import java.util.concurrent.ThreadLocalRandom ; @RestApi ( \"/money\" ) class MyApi { @GET Future < Integer > getMoney (){ Promise < Integer > money = Promise . promise (); /* * Compute my money. It can be done using any asynchronous operation * as long as you don't block Vert.x's Event Loop. */ return money . future (); } @GET ( \"/random\" ) Integer getMoreMoney (){ return ThreadLocalRandom . current (). nextInt (); } @POST void generateMoney (){ System . err . println ( \"This might increase the inflation!\" ); int generated = ThreadLocalRandom . current (). nextInt (); System . out . println ( \"Generated money: $\" + generated + \".00\" ); } }","title":"Sending responses to the Http Client"},{"location":"02-rest-apis/#uri-mapping-conventions","text":"As Kos don't replace Vert.x's routing mechanism, but only automates its creation, you still can take full advantage of it when using Kos' annotation. You can use: fixed defined paths - with no placeholders or wildcard marks. e.g. /some/path/ paths that begins with something - e.g. /some/path/* paths with variable placeholders - e.g. /catalogue/products/:producttype/:productid/ It is worth notice though that it doesn't support RegEx mapping though.","title":"URI Mapping Conventions"},{"location":"02-rest-apis/#capturing-parameters","text":"The following sub-topics will describe how to capture parameters received from the Http Client (e.g. path parameters) in your Rest endpoint method. As parameters are received as either CharSequence or String by the Vert.x core, they will be converted into the desired type by the String Converter Mechanism beforehand, making these values available for developers transparently. A few rules apply though: You have to define the placeholder name you are willing to use If you haven't defined the parameter name, the parameter variable name will be used instead If the defined name doesn't match any existing placeholder, an Exception might be thrown If you have defined a complex object for you captured parameter, and no converted has been defined to that given type, an Exception might be thrown","title":"Capturing parameters"},{"location":"02-rest-apis/#path-parameters","text":"All the matched path placeholders can be easily mapped as parameters in your just created method by using the kos.rest.Path annotation. Kotlin import kos.rest.* @RestApi class MyApi { @GET ( \"/calc/number/:a\" ) fun getMoney ( @Param a : String ) = a @POST ( \"/calc/plus/:a/:b\" ) fun generateMoney ( @Param ( \"a\" ) first : Int , @Param ( \"b\" ) second : Int ) = first + second } Java import kos.rest.* ; @RestApi class MyApi { @GET ( \"/calc/number/:a\" ) Integer getMoney ( @Param Integer a ){ return a ; } @POST ( \"/calc/plus/:a/:b\" ) Integer generateMoney ( @Param ( \"a\" ) Integer first , @Param ( \"b\" ) Integer second ) { return first + second ; } }","title":"Path Parameters"},{"location":"02-rest-apis/#query-parameters","text":"As Vert.x treats query parameters and paths similarly (both being accessible via io.vertx.core.http.HttpServerRequest.getParam(String) ), you can use the same kos.rest.Path to capture query strings as well.","title":"Query parameters"},{"location":"02-rest-apis/#http-headers","text":"Similarly to path and query parameters, we can capture headers send by the Http Client by using the kos.rest.Header annotation. Kotlin import kos.rest.* @RestApi class MyApi { @GET ( \"/what-is-my-user-agent\" ) fun whatIsMyUserAgent ( @Param ( \"Content-Type\" ) contentType : String ) = contentType } Java import kos.rest.* ; @RestApi class MyApi { @GET ( \"/what-is-my-user-agent\" ) String whatIsMyUserAgent ( @Param ( \"Content-Type\" ) String contentType ) { return contentType ; } }","title":"Http Headers"},{"location":"02-rest-apis/#capturing-the-request-payload","text":"As you might imagine, similarly to capturing other params you can capture the request payload sent in the Http Request's body using an annotation. In this case, it will be kos.rest.Body . Unlike other parameters though, payloads will be converted into an object by the default Serializer Mechanism configured on your application. Kotlin import kos.rest.* @RestApi class MyApi { @POST ( \"/money\" ) fun sendMoney ( @Body request : SendMoneyRequest ) = \" ${ request . to } has received $ ${ request . amount } \" } data class SendMoneyRequest ( val to : String , val amount : Double ) Java import kos.rest.* ; @RestApi class MyApi { @POST ( \"/money\" ) String sendMoney ( @Body SendMoneyRequest request ) { return request . to \" has received $\" + request . amount ; } } class SendMoneyRequest { String to ; Double amount ; // getters and setters }","title":"Capturing the request payload"},{"location":"03-rest-clients/","text":"Rest Clients Write down rest clients is usually a task most people doesn't like to do, specially in the JVM ecosystem. We have several Http abstractions and implementations, each of them with different dependency stack. Vert.x team introduced a web client API on their vertx-web module seamlessly integrated with vertx-core , avoiding developers to face the so called dependency-hell. By borrowing a few ideas from Netflix Feign and other known open source frameworks, Kos provides a simple API to create Rest Clients that takes advantage of the well crafted vertx-web module. And, if you've read the Rest API documentation, you'll notice that Rest Clients also relies on kos.rest.* annotations being semantically similar to its Rest API , so you only have to memorize a single set of annotations. It means: you can use the same annotations to map endpoints to methods the same applies to map path parameters , query parameters and headers to arguments You can even use the same Body annotation to serialize and send request payloads Interfaces as API entrypoints The biggest difference though lies on the fact that you don't write concrete classes, but interfaces to define your Rest Clients. You also have to annotate them with kos.rest.RestClient instead of the kos.core.RestApi one. Kotlin import kos.rest.* @RestClient ( \"/calc\" ) interface CalculatorApiClient { @GET ( \"/plus/:a/:b\" ) fun plus ( @Param a : Int , @Param b : Int ): Future < Int > @GET ( \"/minus/:a/:b\" ) fun minus ( @Param a : Int , @Param b : Int ): Future < Int > } Java import kos.rest.* ; @RestClient ( \"/calc\" ) interface CalculatorApiClient { @GET ( \"/plus/:a/:b\" ) Future < Int > plus ( @Param Integer a , @Param Integer b ); @GET ( \"/minus/:a/:b\" ) Future < Int > minus ( @Param Integer a , @Param Integer b ); } Consuming responses to the Http Server Kos Rest API's will infer the response from the return type defined on your functions: void : methods that doesn't return a value will make the call to the desired API in a fire-and-forget fashion, completely ignoring the response received by the server. io.vertx.core.Future<?> : Http Clients will hold the received response in a Future object allowing you to handle the response asynchronously on your first convenience. As you probably notice, Http Clients never blocks the event loop. It comes with a few restrictions though: You have no automated mechanism to map failures into objects In case of Http responses other than 2xx an Exception ( UnexpectedRestClientResponse ) will be set as future Response allowing you to manually handle the unexpected behavior. Instantiating your Rest Client Unlike Rest API's endpoints which are automatically deployed by Kos, Rest Clients will only be instantiated when required by your source code. They are instantiated by the RestClientFactory.instantiate(RestClientConfiguration, T) method. Below we discuss how you can instantiate them either using or not dependency injection. You're going to notice that in both cases we need a factory method to expose it to the rest of the system. The big difference is how you can access the factory and the memory consumption they have. For further details on how Dependency Injection works with Kos please process to this topic . Using Dependency Injection Kotlin import injector.* import kos.core.client.RestClientConfiguration @Singleton class CalculatorApiClientConfiguration ( val restClientFactory : RestClientFactory ){ @Produces // Note: for optimal performance you might consider lazy load the client fun produceClient (): CalculatorApiClient { val baseUrl = \"https://empty.url\" val restConf = RestClientConfiguration . withUrl ( baseUrl ). build () return restClientFactory . instantiate ( restConf , CalculatorApiClient :: class . java ) } } @RestApi class MyApi ( val calculator : CalculatorApiClient ) { @GET ( \"/calc/2/plus/2\" ) fun calculateTwoPlusTwo () = calculator . plus ( 2 , 2 ) } Java import injector.* ; import io.vertx.core.Future ; import kos.core.client.RestClientConfiguration ; @Singleton public class CalculatorApiClientConfiguration { final RestClientFactory restClientFactory ; public CalculatorApiClientConfiguration ( RestClientFactory restClientFactory ) { this . restClientFactory = restClientFactory ; } @Produces // Note: for optimal performance you might consider lazy load the client private CalculatorApiClient produceClient () { val baseUrl = \"https://empty.url\" ; val restConf = RestClientConfiguration . withUrl ( baseUrl ). build (); return restClientFactory . instantiate ( restConf , CalculatorApiClient . java ); } } @RestApi public class MyApi { final CalculatorApiClient calculator ; public MyApi ( CalculatorApiClient calculator ) { this . calculator = calculator ; } @GET ( \"/calc/2/plus/2\" ) Future < Integer > calculateTwoPlusTwo () { return calculator . plus ( 2 , 2 ); } } Using plain code Kotlin import kos.core.client.RestClientConfiguration class CalculatorApiClientConfiguration { // Note: for optimal performance please consider to use Kos.implementationLoader to instantiate it val restClientFactory = RestClientFactory (); // Note: for optimal performance you might consider lazy load the client fun produceClient (): CalculatorApiClient { val baseUrl = \"https://empty.url\" val restConf = RestClientConfiguration . withUrl ( baseUrl ). build () return restClientFactory . instantiate ( restConf , CalculatorApiClient :: class . java ) } } @RestApi class MyApi { // Note: for optimal performance please consider to use Kos.implementationLoader to instantiate it val calculator = CalculatorApiClientConfiguration (). produceClient () @GET ( \"/calc/2/plus/2\" ) fun calculateTwoPlusTwo () = calculator . plus ( 2 , 2 ) } Java import io.vertx.core.Future ; import kos.core.client.RestClientConfiguration ; public class CalculatorApiClientConfiguration { // Note: for optimal performance please consider to use Kos.implementationLoader to instantiate it final RestClientFactory restClientFactory = new RestClientFactory (); // Note: for optimal performance you might consider lazy load the client private CalculatorApiClient produceClient () { val baseUrl = \"https://empty.url\" ; val restConf = RestClientConfiguration . withUrl ( baseUrl ). build (); return restClientFactory . instantiate ( restConf , CalculatorApiClient . java ); } } @RestApi public class MyApi { final CalculatorApiClient calculator = new CalculatorApiClientConfiguration (). produceClient (); @GET ( \"/calc/2/plus/2\" ) public Future < Integer > calculateTwoPlusTwo () { return calculator . plus ( 2 , 2 ); } }","title":"Rest Clients"},{"location":"03-rest-clients/#rest-clients","text":"Write down rest clients is usually a task most people doesn't like to do, specially in the JVM ecosystem. We have several Http abstractions and implementations, each of them with different dependency stack. Vert.x team introduced a web client API on their vertx-web module seamlessly integrated with vertx-core , avoiding developers to face the so called dependency-hell. By borrowing a few ideas from Netflix Feign and other known open source frameworks, Kos provides a simple API to create Rest Clients that takes advantage of the well crafted vertx-web module. And, if you've read the Rest API documentation, you'll notice that Rest Clients also relies on kos.rest.* annotations being semantically similar to its Rest API , so you only have to memorize a single set of annotations. It means: you can use the same annotations to map endpoints to methods the same applies to map path parameters , query parameters and headers to arguments You can even use the same Body annotation to serialize and send request payloads","title":"Rest Clients"},{"location":"03-rest-clients/#interfaces-as-api-entrypoints","text":"The biggest difference though lies on the fact that you don't write concrete classes, but interfaces to define your Rest Clients. You also have to annotate them with kos.rest.RestClient instead of the kos.core.RestApi one. Kotlin import kos.rest.* @RestClient ( \"/calc\" ) interface CalculatorApiClient { @GET ( \"/plus/:a/:b\" ) fun plus ( @Param a : Int , @Param b : Int ): Future < Int > @GET ( \"/minus/:a/:b\" ) fun minus ( @Param a : Int , @Param b : Int ): Future < Int > } Java import kos.rest.* ; @RestClient ( \"/calc\" ) interface CalculatorApiClient { @GET ( \"/plus/:a/:b\" ) Future < Int > plus ( @Param Integer a , @Param Integer b ); @GET ( \"/minus/:a/:b\" ) Future < Int > minus ( @Param Integer a , @Param Integer b ); }","title":"Interfaces as API entrypoints"},{"location":"03-rest-clients/#consuming-responses-to-the-http-server","text":"Kos Rest API's will infer the response from the return type defined on your functions: void : methods that doesn't return a value will make the call to the desired API in a fire-and-forget fashion, completely ignoring the response received by the server. io.vertx.core.Future<?> : Http Clients will hold the received response in a Future object allowing you to handle the response asynchronously on your first convenience. As you probably notice, Http Clients never blocks the event loop. It comes with a few restrictions though: You have no automated mechanism to map failures into objects In case of Http responses other than 2xx an Exception ( UnexpectedRestClientResponse ) will be set as future Response allowing you to manually handle the unexpected behavior.","title":"Consuming responses to the Http Server"},{"location":"03-rest-clients/#instantiating-your-rest-client","text":"Unlike Rest API's endpoints which are automatically deployed by Kos, Rest Clients will only be instantiated when required by your source code. They are instantiated by the RestClientFactory.instantiate(RestClientConfiguration, T) method. Below we discuss how you can instantiate them either using or not dependency injection. You're going to notice that in both cases we need a factory method to expose it to the rest of the system. The big difference is how you can access the factory and the memory consumption they have. For further details on how Dependency Injection works with Kos please process to this topic .","title":"Instantiating your Rest Client"},{"location":"03-rest-clients/#using-dependency-injection","text":"Kotlin import injector.* import kos.core.client.RestClientConfiguration @Singleton class CalculatorApiClientConfiguration ( val restClientFactory : RestClientFactory ){ @Produces // Note: for optimal performance you might consider lazy load the client fun produceClient (): CalculatorApiClient { val baseUrl = \"https://empty.url\" val restConf = RestClientConfiguration . withUrl ( baseUrl ). build () return restClientFactory . instantiate ( restConf , CalculatorApiClient :: class . java ) } } @RestApi class MyApi ( val calculator : CalculatorApiClient ) { @GET ( \"/calc/2/plus/2\" ) fun calculateTwoPlusTwo () = calculator . plus ( 2 , 2 ) } Java import injector.* ; import io.vertx.core.Future ; import kos.core.client.RestClientConfiguration ; @Singleton public class CalculatorApiClientConfiguration { final RestClientFactory restClientFactory ; public CalculatorApiClientConfiguration ( RestClientFactory restClientFactory ) { this . restClientFactory = restClientFactory ; } @Produces // Note: for optimal performance you might consider lazy load the client private CalculatorApiClient produceClient () { val baseUrl = \"https://empty.url\" ; val restConf = RestClientConfiguration . withUrl ( baseUrl ). build (); return restClientFactory . instantiate ( restConf , CalculatorApiClient . java ); } } @RestApi public class MyApi { final CalculatorApiClient calculator ; public MyApi ( CalculatorApiClient calculator ) { this . calculator = calculator ; } @GET ( \"/calc/2/plus/2\" ) Future < Integer > calculateTwoPlusTwo () { return calculator . plus ( 2 , 2 ); } }","title":"Using Dependency Injection"},{"location":"03-rest-clients/#using-plain-code","text":"Kotlin import kos.core.client.RestClientConfiguration class CalculatorApiClientConfiguration { // Note: for optimal performance please consider to use Kos.implementationLoader to instantiate it val restClientFactory = RestClientFactory (); // Note: for optimal performance you might consider lazy load the client fun produceClient (): CalculatorApiClient { val baseUrl = \"https://empty.url\" val restConf = RestClientConfiguration . withUrl ( baseUrl ). build () return restClientFactory . instantiate ( restConf , CalculatorApiClient :: class . java ) } } @RestApi class MyApi { // Note: for optimal performance please consider to use Kos.implementationLoader to instantiate it val calculator = CalculatorApiClientConfiguration (). produceClient () @GET ( \"/calc/2/plus/2\" ) fun calculateTwoPlusTwo () = calculator . plus ( 2 , 2 ) } Java import io.vertx.core.Future ; import kos.core.client.RestClientConfiguration ; public class CalculatorApiClientConfiguration { // Note: for optimal performance please consider to use Kos.implementationLoader to instantiate it final RestClientFactory restClientFactory = new RestClientFactory (); // Note: for optimal performance you might consider lazy load the client private CalculatorApiClient produceClient () { val baseUrl = \"https://empty.url\" ; val restConf = RestClientConfiguration . withUrl ( baseUrl ). build (); return restClientFactory . instantiate ( restConf , CalculatorApiClient . java ); } } @RestApi public class MyApi { final CalculatorApiClient calculator = new CalculatorApiClientConfiguration (). produceClient (); @GET ( \"/calc/2/plus/2\" ) public Future < Integer > calculateTwoPlusTwo () { return calculator . plus ( 2 , 2 ); } }","title":"Using plain code"},{"location":"11-dependency-injection/","text":"Dependency Injection Kos uses Dependency Injection as a way to allow developers to orthogonally customize applications without changing their codebase. This allowed Kos to generate source code, reducing the amount of code required by developers to write down everyday routines like Rest APIs and Web Clients. Implementation Loaders Internally, Kos refers to Dependency Injection mechanisms as Implementation Loaders . They are responsible to perform two basic tasks the Kos needs all the time: Load an object implementing a given Interface - or extending a given class Load all objects implementing a given Interface - or extending a given class The next topics will cover all DI mechanism provided out-of-box with Kos. JDK Service Provider Although it is not considered a proper Dependency Injection implementation, the ServiceLoader implementation that is bundled with JDK is versatile enough to meet the two above mentioned requirements. If you want to keep you footprint small, Service Provider might be a good solution. It is the default Implementation Loader mechanism. To provide an implementation of a given Kos service all you have to do is implement a given interface (or extend a given class) and create a Service Provider meta information in the META-INF/services folder. For more details on designing a service provide please read the ServiceLoader documentation available here . Injector Info For more details on how Injector works, please proceed to its documentation . Injector is lightweight and zero-overhead dependency injection library for JVM developers. It was carefully designed to make no-use of reflection by having all required meta-information computed at compile time. At runtime it performs only the necessary tasks required to instantiate classes and have its dependencies injected. The result is a blistering fast Dependency Injection implementation that has less than 7kb of footprint. To provide an implementation of a given Kos service all you have to do is implement a given interface (or extend a given class) and annotate with injector.ExposedAs annotation. Also, to make ordinary classes able to be managed by Injector you should annotated them with either injector.Singleton or injector.New . Below you can find a Custom Exception Handler implementation. import injector.ExposedAs ; import kos.api.ExceptionHandler ; import kos.api.Response ; @ExposedAs ( ExceptionHandler . class ) public class CustomExceptionHandler implements ExceptionHandler { public Response handle ( RoutingContext request , Throwable cause ){ if ( cause instanceof IllegalArgumentException ) return Response . BAD_REQUEST ; return Response . of ( cause . getMessage ()). statusCode ( 500 ); } } To use Injector as default Implementation Loader you need to import kos-injector module on your project. Gradle (kts) implementation ( \"io.skullabs.kos:kos-injector\" ) Maven (pom.kts) compile ( \"io.skullabs.kos:kos-injector\" ) Maven (pom.xml) <dependency> <groupId> io.skullabs.kos </groupId> <artifactId> kos-injector </artifactId> </dependency> Guice Info Although we have plans to support Guice in the near future, we hasn't created a module to officially support it yet. Please send us a thumbs up here so we know in what to put more effort for the releases. Custom Dependency Injection Mechanism As mentioned before Kos dependency injection mechanism is quite simple and doesn't enforce you to stick with a single implementation. To provide your own Implementaion Loader you need to implement the kos.api.ImplementationLoader interface. Once you've implemented you need to register it as the default Implementation Loader by exposing it as Service Provider implementation. You can do so by creating a META-INF/services/kos.api.ImplementationLoader file with the canonical name of your just created class inside of it.","title":"Dependency Injection"},{"location":"11-dependency-injection/#dependency-injection","text":"Kos uses Dependency Injection as a way to allow developers to orthogonally customize applications without changing their codebase. This allowed Kos to generate source code, reducing the amount of code required by developers to write down everyday routines like Rest APIs and Web Clients.","title":"Dependency Injection"},{"location":"11-dependency-injection/#implementation-loaders","text":"Internally, Kos refers to Dependency Injection mechanisms as Implementation Loaders . They are responsible to perform two basic tasks the Kos needs all the time: Load an object implementing a given Interface - or extending a given class Load all objects implementing a given Interface - or extending a given class The next topics will cover all DI mechanism provided out-of-box with Kos.","title":"Implementation Loaders"},{"location":"11-dependency-injection/#jdk-service-provider","text":"Although it is not considered a proper Dependency Injection implementation, the ServiceLoader implementation that is bundled with JDK is versatile enough to meet the two above mentioned requirements. If you want to keep you footprint small, Service Provider might be a good solution. It is the default Implementation Loader mechanism. To provide an implementation of a given Kos service all you have to do is implement a given interface (or extend a given class) and create a Service Provider meta information in the META-INF/services folder. For more details on designing a service provide please read the ServiceLoader documentation available here .","title":"JDK Service Provider"},{"location":"11-dependency-injection/#injector","text":"Info For more details on how Injector works, please proceed to its documentation . Injector is lightweight and zero-overhead dependency injection library for JVM developers. It was carefully designed to make no-use of reflection by having all required meta-information computed at compile time. At runtime it performs only the necessary tasks required to instantiate classes and have its dependencies injected. The result is a blistering fast Dependency Injection implementation that has less than 7kb of footprint. To provide an implementation of a given Kos service all you have to do is implement a given interface (or extend a given class) and annotate with injector.ExposedAs annotation. Also, to make ordinary classes able to be managed by Injector you should annotated them with either injector.Singleton or injector.New . Below you can find a Custom Exception Handler implementation. import injector.ExposedAs ; import kos.api.ExceptionHandler ; import kos.api.Response ; @ExposedAs ( ExceptionHandler . class ) public class CustomExceptionHandler implements ExceptionHandler { public Response handle ( RoutingContext request , Throwable cause ){ if ( cause instanceof IllegalArgumentException ) return Response . BAD_REQUEST ; return Response . of ( cause . getMessage ()). statusCode ( 500 ); } } To use Injector as default Implementation Loader you need to import kos-injector module on your project. Gradle (kts) implementation ( \"io.skullabs.kos:kos-injector\" ) Maven (pom.kts) compile ( \"io.skullabs.kos:kos-injector\" ) Maven (pom.xml) <dependency> <groupId> io.skullabs.kos </groupId> <artifactId> kos-injector </artifactId> </dependency>","title":"Injector"},{"location":"11-dependency-injection/#guice","text":"Info Although we have plans to support Guice in the near future, we hasn't created a module to officially support it yet. Please send us a thumbs up here so we know in what to put more effort for the releases.","title":"Guice"},{"location":"11-dependency-injection/#custom-dependency-injection-mechanism","text":"As mentioned before Kos dependency injection mechanism is quite simple and doesn't enforce you to stick with a single implementation. To provide your own Implementaion Loader you need to implement the kos.api.ImplementationLoader interface. Once you've implemented you need to register it as the default Implementation Loader by exposing it as Service Provider implementation. You can do so by creating a META-INF/services/kos.api.ImplementationLoader file with the canonical name of your just created class inside of it.","title":"Custom Dependency Injection Mechanism"},{"location":"21-kos-architecture/","text":"Kos Architecture Overview In the following topics we're going to introduce you the main points that Kos may come in handy on your project, how it reduces boilerplate codes but keeps the performance close to a pure Vert.x solution. Differences between VertX and Kos To understand the benefits of using Kos, lets create a trivial CRUD of User . Below, we have a basic source code that covers the creation, removal and retrieval of user. We'll use it as persistence layer for two experiments: one using Kos and another one using pure Vert.x. User.java import lombok.* ; import java.util.* ; @Data public class User { final UUID id = UUID . randomUUID (); String name ; ZonedDateTime creationDate ; } UserRepository.java import io.vertx.core.* ; import java.time.* ; import java.util.* ; interface UserRepository { Future < User > retrieveUserById ( UUID id ); Future < List < User >> retrieveUsersCreatedBetween ( ZonedDateTime initialDate , ZonedDateTime endDate ); Future < UUID > createUser ( User user ); Future < Void > removeUser ( UUID id ); } It is worth mention that: All the example files bellow are written in Java, although it may look similar if written in Kotlin or Scala. User.java is the entity to be stored in the database - later we'll also use it as a model in our Rest API. For brevity, it uses Lombok to make example simpler. UserRepository.java the concrete implementation of our repository. For brevity, we've designed it as an interface. Lets assume that we have a class DefaultUserRepository else where that properly implements the required methods. Vanilla Vert.x Webapp App.java import io.vertx.core.* ; import io.vertx.core.http.* ; import io.vertx.ext.web.* ; import java.util.* ; import lombok.* ; public class App { // 1 private final Vertx vertx = Vertx . create (); private final Logger logger = LoggerFactory . getLogger ( this . getClass ()); void start () { val configRetriever = loadConfigRetriever (); // 2 configRetriever . getConfig ( res -> { if ( res . failed ()) { handleFatalFailure ( \"Failed to load configuration\" , res . cause ()); } else { Router router = Router . router ( vertx ); // 3 // Ensure any POST message will have its body payload buffered before the // expected request handler method is called. router . post (). handler ( BodyHandler . create () ); val config = res . result (); deployVerticlesWithConfig ( router , config ); startVertxHttpServer ( router , config ); } }); } private ConfigRetriever loadConfigRetriever () { val store = new ConfigStoreOptions () . setOptional ( true ) . setType ( \"file\" ) . setFormat ( \"yaml\" ) . setConfig ( new JsonObject (). put ( \"path\" , \"conf/application.yml\" )); val retrieverOptions = new ConfigRetrieverOptions (); retrieverOptions . addStore ( store ); return ConfigRetriever . create ( vertx , retrieverOptions ); } private void deployVerticlesWithConfig ( Router router , JsonObject config ){ val options = new DeploymentOptions (). setConfig ( res . result ()); val repository = new DefaultUserRepository (); val userVerticle = UserApi . with ( router , repository ); vertx . deployVerticle ( verticle , options ); // 4 } private void startVertxHttpServer ( Router router , JsonObject config ){ val httpOptions = new HttpServerOptions ( config ); vertx . createHttpServer ( httpServerOptions ) . requestHandler ( router ) . listen ( res -> { if ( res . failed () ) { handleFatalFailure ( \"Could not start server\" , as . cause () ); } else { val server = res . result (); Runtime . getRuntime (). addShutdownHook ( new Thread ( server :: close )); logger . info ( \"Application started and listening for requests\" ); } }); } private void handleFatalFailure ( String message , Throwable cause ) { log . fatal ( message , cause ); System . exit ( 1 ); } // Starts the application from the command line. public static void main ( String [] args ){ System . setProperty ( // 5 \"vertx.logger-delegate-factory-class-name\" , SLF4JLogDelegateFactory . class . getCanonicalName () ); new App (). start (); } } UserApi.java import io.vertx.core.http.* ; import io.vertx.core.buffer.* ; import io.vertx.core.logging.* ; import io.vertx.core.json.* ; import io.vertx.ext.web.* ; import java.util.* ; import java.time.* ; import lombok.* ; class UserApi { // 6 final Logger logger = LoggerFactory . getLogger ( this . getClass ()); final UserRepository repository ; UserApi ( UserRepository repository ) { this . repository = repository ; } void retrieveUserById ( RoutingContext event ) { val idAsString = event . request (). params (). get ( \"id\" ); val id = isAsString == null ? null : UUID . fromString ( isAsString ); // 7 repository . retrieveUserById ( id ) . setHandler ( UserApi :: defaultResponseHandler ); // 8 } void retrieveUsersCreatedBetween ( RoutingContext event ) { val initialDateAsString = event . request (). params (). get ( \"initDate\" ); val initialDate = ZonedDateTime . parse ( initialDateAsString ); val endDateAsString = event . request (). params (). get ( \"endDate\" ); val endDate = ZonedDateTime . parse ( endDateAsString ); retrieveUsersCreatedBetween ( initialDate , endDate ) . setHandler ( UserApi :: defaultResponseHandler ); } void createUser ( RoutingContext event ) { val user = Json . decodeValue ( context . getBody (), User . class ); createUser ( user ) . setHandler ( UserApi :: defaultResponseHandler ); } void removeUser ( RoutingContext event ) { val idAsString = event . request (). params (). get ( \"id\" ); val id = isAsString == null ? null : UUID . fromString ( isAsString ); removeUser ( id ) . setHandler ( UserApi :: defaultResponseHandler ); } static < T > void defaultResponseHandler ( AsyncResult < T > res ) { // 9 if ( res . failed ()) { sendInternalServerError ( event , res . cause ()); } else { sendOkResponseAsJson ( event , res . result ()); } } static void sendInternalServerError ( RoutingContext event , Throwable cause ) { // 10 val req = event . request (); logger . error ( \"Failed to handle request: \" + req .. method () + \" - \" + . path (), cause ); event . response (). setStatusCode ( 500 ). end (); } static void sendOkResponseAsJson ( RoutingContext event , Object object ) { val buffer = Json . encodeToBuffer ( object ); // 11 event . response () . putHeader ( HttpHeaders . CONTENT_TYPE , \"application/json\" ) . setStatusCode ( 200 ) . end ( buffer ); } static UserApi create ( Router router , UserRepository repository ) { val api = UserApi ( repository ); router . get ( \"/users/:id\" , api :: retrieveUserById ); // 12 router . get ( \"/users/:initDate/:endDate\" , api :: retrieveUsersCreatedBetween ); router . post ( \"/users\" , api :: createUser ); router . delete ( \"/users/:id\" , api :: removeUser ); return api ; } } Although the above application is perfectly efficient and fast as it is reliant on Vert.x core, the code itself is far from simple. Let's dive into the source code and look into the numbered lines to understand what it's actually doing. The App class is responsible for starting the web server, providing everything is absolutely necessary to deploy our verticles. Usually the pieces here configured doesn't change that often. It will read the configuration file as the first thing will happen when the application start, exiting the application once it fails. The router will be used as argument for our verticles. Following the instructions of the official documentation, here it has been configured to eagerly read body payloads received by any POST request. Manually deploying Verticles is not a hard task although it comes with its own challenges. Due to the flexible nature of Vertx Web API, there's not standard way to organize the source code and deploy our web verticles. A simple look into the available vertx examples and you'll easily notice that. Here we've decided to delegate the endpoint mapping to the verticle itself, centralizing the routing strategy in a single place. The JVM ecosystem has several mature and reliable log frameworks which diverges in contract and configuration. Thankfully Vertx Core has it's logging mechanism configurable. Here we forced to use popular SLF4J as logger implementation. This strategy also allows us to provide a self-contained package that doesn't expects command line parameters to spin the application. The UserApi class acts bridge between our Rest API and the UserRepository . Depending on how big are the changes in requirements, this class may have to be changed frequently by the developers. Extracting parameters from the request is a trivial task too. It can be tricky though to parse strings values, check for nullable values and pass the values to the expected business logic (in our case, our repository). Underneath Vert.x makes heavily usage of its netty-based Event Loop implementation. Smart developers will never block the EL and will always rely on non-blocking or asynchronous APIs to perform calls to a downstream service. The caveat though is that we should properly compose Future and Promise objects in order to provide a consistent and integer API to our users. Here we have our centralized handler that is used any time we need to analyze Future objects and send a response to the client of our Rest API. Our naive error handler implementation here is straightforward, sending a simple 500 response to the Http client. Response serialization is something that should be manually handled here and if properly written will not impact that much on developers productivity. As described before, the Route Mapping algorithm has been moved to the UserApi class, as it makes sense to have the mapping and the bridge methods in the same place. Kos webapp The above steps indeed makes sense and covers a fairly amount of features that is expected from a development platform, although one may expect to have less work to bridge their business logic from the network. Kos comes as tool to significantly reduce this layer. UserApi.java import java.util.* ; import java.time.* ; import kos.rest.* ; import lombok.extern.slf4j.Slf4j ; import injector.Singleton ; @Slf4j @Path ( \"users\" ) @Singleton class UserApi { final UserRepository repository ; UserApi ( UserRepository repository ) { this . repository = repository ; } @GET ( \":id\" ) Future < User > retrieveUserById ( @Param UUID id ) { return repository . retrieveUserById ( id ); } @GET ( \":initDate/:endDate\" ) Future < List < User >> retrieveUsersCreatedBetween ( @Param ZonedDateTime initDate , @Param ZonedDateTime endDate ) { return repository . retrieveUsersCreatedBetween ( initDate , endDate ); } @POST Future < UUID > createUser ( User user ) { return repository . createUser ( user ); } @DELETE ( \":id\" ) Future < Void > removeUser ( UUID id ) { return repository . removeUser ( id ); } } It was rather simplified. Let's walk through the biggest differences we have between both examples. The first thing that draws our attention once we read the source code is the introduction of Kos annotations that are used as mapping entry points. It is mainly used to mark routing methods and automatically bind them to a Rest endpoint. Our controller is not being manually bond to the Vert.x Router or event the Vertx instance. In fact, we don't even had to configure a Vertx application at all. Underneath a new Vertx and Router instance will be spun up and use it whenever you use the Kos annotations. The introduction of the injector.Singleton annotation. Kos is very flexible and provides a versatile dependency injection where you can optionally use your favorite Dependency Injection framework. Out-of-box though it only supports Injector and SPI classes - more on that below. Dependency Injection: Kos' Backbone Dependency injection is the literally Kos' backbone. As you can imagine from the previous examples, in order to simplify the way you design a Rest API a few conventions has been adopted to automatically discovery your endpoints, to deploy verticles and even read the configuration file from the file system. Looking to the steps we usually do in order to have a Vert.x application up and running, we figured out that Kos should perform the following during the boot: Load all classes implementing io.vertx.core.Verticle : We need a way to discovery verticles and deploy them automatically. Load configuration automatically: It's also convenient to have the configuration file loaded automatically once the application is started. Discovery Rest endpoints automatically - or at least provide a way for developers to access Vert.x Router . Figure out which (supported) log API the developer is using and make Vert.x use it automatically - instead of manually set a parameter in command line every time you spin up your server. There are multiple ways to achieve these goals, and few libraries can easily provide that for us. There are though a few assumptions that we had to assess them: Everything should be optional. Any automation should be consciously triggered by the developers will. It should have little to no cost during the application startup. It should impose no-overhead in our application runtime. Taking the previously mentioned item 1 as an example, the optimal scenario should deploy all the classes which implements Verticle interface, but only the ones intentionally marked as \"discoverable\". After a few days of research and experiments we can with the idea of using Java 6 Service Provider Interfaces (SPI) to discover those implementations. It obviously fits our requirements, and requires no external dependency. The major limitation of SPI lies on the fact that your classes should have a default (no-args) constructor. This can impose severe restrictions on how developers will bridge their business logic from the Rest API. It forced us to make Dependency Injection customizable . Injector is an optional dependency injector that can be used to surpass such limitations, as it also fits into our requirements, makes no-use of reflection and class loader, and is standalone - no external dependency. A list of alternative supported DI frameworks can be found here . WebService Verticle kos.core.VertxWebServer is an special Verticle implementation that comes with the kos-core module. It is responsible for: Spinning up Vert.x Router and the HttpServer . Discovering Rest endpoints mapped via kos-annotations Trigger all implementations of WebServerEventListener Kos Launcher Kos applications are started by the kos.core.Launcher class. Its main job is: Lookup for all classes that implements Verticle interface - exposed as SPI - and automatically deploy them. Lookup for the first ConfigRetriever implementations - exposed as SPI - and automatically deploy it.","title":"Kos Architecture Overview"},{"location":"21-kos-architecture/#kos-architecture-overview","text":"In the following topics we're going to introduce you the main points that Kos may come in handy on your project, how it reduces boilerplate codes but keeps the performance close to a pure Vert.x solution.","title":"Kos Architecture Overview"},{"location":"21-kos-architecture/#differences-between-vertx-and-kos","text":"To understand the benefits of using Kos, lets create a trivial CRUD of User . Below, we have a basic source code that covers the creation, removal and retrieval of user. We'll use it as persistence layer for two experiments: one using Kos and another one using pure Vert.x. User.java import lombok.* ; import java.util.* ; @Data public class User { final UUID id = UUID . randomUUID (); String name ; ZonedDateTime creationDate ; } UserRepository.java import io.vertx.core.* ; import java.time.* ; import java.util.* ; interface UserRepository { Future < User > retrieveUserById ( UUID id ); Future < List < User >> retrieveUsersCreatedBetween ( ZonedDateTime initialDate , ZonedDateTime endDate ); Future < UUID > createUser ( User user ); Future < Void > removeUser ( UUID id ); } It is worth mention that: All the example files bellow are written in Java, although it may look similar if written in Kotlin or Scala. User.java is the entity to be stored in the database - later we'll also use it as a model in our Rest API. For brevity, it uses Lombok to make example simpler. UserRepository.java the concrete implementation of our repository. For brevity, we've designed it as an interface. Lets assume that we have a class DefaultUserRepository else where that properly implements the required methods.","title":"Differences between VertX and Kos"},{"location":"21-kos-architecture/#vanilla-vertx-webapp","text":"App.java import io.vertx.core.* ; import io.vertx.core.http.* ; import io.vertx.ext.web.* ; import java.util.* ; import lombok.* ; public class App { // 1 private final Vertx vertx = Vertx . create (); private final Logger logger = LoggerFactory . getLogger ( this . getClass ()); void start () { val configRetriever = loadConfigRetriever (); // 2 configRetriever . getConfig ( res -> { if ( res . failed ()) { handleFatalFailure ( \"Failed to load configuration\" , res . cause ()); } else { Router router = Router . router ( vertx ); // 3 // Ensure any POST message will have its body payload buffered before the // expected request handler method is called. router . post (). handler ( BodyHandler . create () ); val config = res . result (); deployVerticlesWithConfig ( router , config ); startVertxHttpServer ( router , config ); } }); } private ConfigRetriever loadConfigRetriever () { val store = new ConfigStoreOptions () . setOptional ( true ) . setType ( \"file\" ) . setFormat ( \"yaml\" ) . setConfig ( new JsonObject (). put ( \"path\" , \"conf/application.yml\" )); val retrieverOptions = new ConfigRetrieverOptions (); retrieverOptions . addStore ( store ); return ConfigRetriever . create ( vertx , retrieverOptions ); } private void deployVerticlesWithConfig ( Router router , JsonObject config ){ val options = new DeploymentOptions (). setConfig ( res . result ()); val repository = new DefaultUserRepository (); val userVerticle = UserApi . with ( router , repository ); vertx . deployVerticle ( verticle , options ); // 4 } private void startVertxHttpServer ( Router router , JsonObject config ){ val httpOptions = new HttpServerOptions ( config ); vertx . createHttpServer ( httpServerOptions ) . requestHandler ( router ) . listen ( res -> { if ( res . failed () ) { handleFatalFailure ( \"Could not start server\" , as . cause () ); } else { val server = res . result (); Runtime . getRuntime (). addShutdownHook ( new Thread ( server :: close )); logger . info ( \"Application started and listening for requests\" ); } }); } private void handleFatalFailure ( String message , Throwable cause ) { log . fatal ( message , cause ); System . exit ( 1 ); } // Starts the application from the command line. public static void main ( String [] args ){ System . setProperty ( // 5 \"vertx.logger-delegate-factory-class-name\" , SLF4JLogDelegateFactory . class . getCanonicalName () ); new App (). start (); } } UserApi.java import io.vertx.core.http.* ; import io.vertx.core.buffer.* ; import io.vertx.core.logging.* ; import io.vertx.core.json.* ; import io.vertx.ext.web.* ; import java.util.* ; import java.time.* ; import lombok.* ; class UserApi { // 6 final Logger logger = LoggerFactory . getLogger ( this . getClass ()); final UserRepository repository ; UserApi ( UserRepository repository ) { this . repository = repository ; } void retrieveUserById ( RoutingContext event ) { val idAsString = event . request (). params (). get ( \"id\" ); val id = isAsString == null ? null : UUID . fromString ( isAsString ); // 7 repository . retrieveUserById ( id ) . setHandler ( UserApi :: defaultResponseHandler ); // 8 } void retrieveUsersCreatedBetween ( RoutingContext event ) { val initialDateAsString = event . request (). params (). get ( \"initDate\" ); val initialDate = ZonedDateTime . parse ( initialDateAsString ); val endDateAsString = event . request (). params (). get ( \"endDate\" ); val endDate = ZonedDateTime . parse ( endDateAsString ); retrieveUsersCreatedBetween ( initialDate , endDate ) . setHandler ( UserApi :: defaultResponseHandler ); } void createUser ( RoutingContext event ) { val user = Json . decodeValue ( context . getBody (), User . class ); createUser ( user ) . setHandler ( UserApi :: defaultResponseHandler ); } void removeUser ( RoutingContext event ) { val idAsString = event . request (). params (). get ( \"id\" ); val id = isAsString == null ? null : UUID . fromString ( isAsString ); removeUser ( id ) . setHandler ( UserApi :: defaultResponseHandler ); } static < T > void defaultResponseHandler ( AsyncResult < T > res ) { // 9 if ( res . failed ()) { sendInternalServerError ( event , res . cause ()); } else { sendOkResponseAsJson ( event , res . result ()); } } static void sendInternalServerError ( RoutingContext event , Throwable cause ) { // 10 val req = event . request (); logger . error ( \"Failed to handle request: \" + req .. method () + \" - \" + . path (), cause ); event . response (). setStatusCode ( 500 ). end (); } static void sendOkResponseAsJson ( RoutingContext event , Object object ) { val buffer = Json . encodeToBuffer ( object ); // 11 event . response () . putHeader ( HttpHeaders . CONTENT_TYPE , \"application/json\" ) . setStatusCode ( 200 ) . end ( buffer ); } static UserApi create ( Router router , UserRepository repository ) { val api = UserApi ( repository ); router . get ( \"/users/:id\" , api :: retrieveUserById ); // 12 router . get ( \"/users/:initDate/:endDate\" , api :: retrieveUsersCreatedBetween ); router . post ( \"/users\" , api :: createUser ); router . delete ( \"/users/:id\" , api :: removeUser ); return api ; } } Although the above application is perfectly efficient and fast as it is reliant on Vert.x core, the code itself is far from simple. Let's dive into the source code and look into the numbered lines to understand what it's actually doing. The App class is responsible for starting the web server, providing everything is absolutely necessary to deploy our verticles. Usually the pieces here configured doesn't change that often. It will read the configuration file as the first thing will happen when the application start, exiting the application once it fails. The router will be used as argument for our verticles. Following the instructions of the official documentation, here it has been configured to eagerly read body payloads received by any POST request. Manually deploying Verticles is not a hard task although it comes with its own challenges. Due to the flexible nature of Vertx Web API, there's not standard way to organize the source code and deploy our web verticles. A simple look into the available vertx examples and you'll easily notice that. Here we've decided to delegate the endpoint mapping to the verticle itself, centralizing the routing strategy in a single place. The JVM ecosystem has several mature and reliable log frameworks which diverges in contract and configuration. Thankfully Vertx Core has it's logging mechanism configurable. Here we forced to use popular SLF4J as logger implementation. This strategy also allows us to provide a self-contained package that doesn't expects command line parameters to spin the application. The UserApi class acts bridge between our Rest API and the UserRepository . Depending on how big are the changes in requirements, this class may have to be changed frequently by the developers. Extracting parameters from the request is a trivial task too. It can be tricky though to parse strings values, check for nullable values and pass the values to the expected business logic (in our case, our repository). Underneath Vert.x makes heavily usage of its netty-based Event Loop implementation. Smart developers will never block the EL and will always rely on non-blocking or asynchronous APIs to perform calls to a downstream service. The caveat though is that we should properly compose Future and Promise objects in order to provide a consistent and integer API to our users. Here we have our centralized handler that is used any time we need to analyze Future objects and send a response to the client of our Rest API. Our naive error handler implementation here is straightforward, sending a simple 500 response to the Http client. Response serialization is something that should be manually handled here and if properly written will not impact that much on developers productivity. As described before, the Route Mapping algorithm has been moved to the UserApi class, as it makes sense to have the mapping and the bridge methods in the same place.","title":"Vanilla Vert.x Webapp"},{"location":"21-kos-architecture/#kos-webapp","text":"The above steps indeed makes sense and covers a fairly amount of features that is expected from a development platform, although one may expect to have less work to bridge their business logic from the network. Kos comes as tool to significantly reduce this layer. UserApi.java import java.util.* ; import java.time.* ; import kos.rest.* ; import lombok.extern.slf4j.Slf4j ; import injector.Singleton ; @Slf4j @Path ( \"users\" ) @Singleton class UserApi { final UserRepository repository ; UserApi ( UserRepository repository ) { this . repository = repository ; } @GET ( \":id\" ) Future < User > retrieveUserById ( @Param UUID id ) { return repository . retrieveUserById ( id ); } @GET ( \":initDate/:endDate\" ) Future < List < User >> retrieveUsersCreatedBetween ( @Param ZonedDateTime initDate , @Param ZonedDateTime endDate ) { return repository . retrieveUsersCreatedBetween ( initDate , endDate ); } @POST Future < UUID > createUser ( User user ) { return repository . createUser ( user ); } @DELETE ( \":id\" ) Future < Void > removeUser ( UUID id ) { return repository . removeUser ( id ); } } It was rather simplified. Let's walk through the biggest differences we have between both examples. The first thing that draws our attention once we read the source code is the introduction of Kos annotations that are used as mapping entry points. It is mainly used to mark routing methods and automatically bind them to a Rest endpoint. Our controller is not being manually bond to the Vert.x Router or event the Vertx instance. In fact, we don't even had to configure a Vertx application at all. Underneath a new Vertx and Router instance will be spun up and use it whenever you use the Kos annotations. The introduction of the injector.Singleton annotation. Kos is very flexible and provides a versatile dependency injection where you can optionally use your favorite Dependency Injection framework. Out-of-box though it only supports Injector and SPI classes - more on that below.","title":"Kos webapp"},{"location":"21-kos-architecture/#dependency-injection-kos-backbone","text":"Dependency injection is the literally Kos' backbone. As you can imagine from the previous examples, in order to simplify the way you design a Rest API a few conventions has been adopted to automatically discovery your endpoints, to deploy verticles and even read the configuration file from the file system. Looking to the steps we usually do in order to have a Vert.x application up and running, we figured out that Kos should perform the following during the boot: Load all classes implementing io.vertx.core.Verticle : We need a way to discovery verticles and deploy them automatically. Load configuration automatically: It's also convenient to have the configuration file loaded automatically once the application is started. Discovery Rest endpoints automatically - or at least provide a way for developers to access Vert.x Router . Figure out which (supported) log API the developer is using and make Vert.x use it automatically - instead of manually set a parameter in command line every time you spin up your server. There are multiple ways to achieve these goals, and few libraries can easily provide that for us. There are though a few assumptions that we had to assess them: Everything should be optional. Any automation should be consciously triggered by the developers will. It should have little to no cost during the application startup. It should impose no-overhead in our application runtime. Taking the previously mentioned item 1 as an example, the optimal scenario should deploy all the classes which implements Verticle interface, but only the ones intentionally marked as \"discoverable\". After a few days of research and experiments we can with the idea of using Java 6 Service Provider Interfaces (SPI) to discover those implementations. It obviously fits our requirements, and requires no external dependency. The major limitation of SPI lies on the fact that your classes should have a default (no-args) constructor. This can impose severe restrictions on how developers will bridge their business logic from the Rest API. It forced us to make Dependency Injection customizable . Injector is an optional dependency injector that can be used to surpass such limitations, as it also fits into our requirements, makes no-use of reflection and class loader, and is standalone - no external dependency. A list of alternative supported DI frameworks can be found here .","title":"Dependency Injection: Kos' Backbone"},{"location":"21-kos-architecture/#webservice-verticle","text":"kos.core.VertxWebServer is an special Verticle implementation that comes with the kos-core module. It is responsible for: Spinning up Vert.x Router and the HttpServer . Discovering Rest endpoints mapped via kos-annotations Trigger all implementations of WebServerEventListener","title":"WebService Verticle"},{"location":"21-kos-architecture/#kos-launcher","text":"Kos applications are started by the kos.core.Launcher class. Its main job is: Lookup for all classes that implements Verticle interface - exposed as SPI - and automatically deploy them. Lookup for the first ConfigRetriever implementations - exposed as SPI - and automatically deploy it.","title":"Kos Launcher"}]}