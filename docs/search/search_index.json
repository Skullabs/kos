{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"getting-started/","text":"Getting Started Info Don't want to follow the following steps by yourself? What about downloading a blueprint project that you can change according to your needs? Gradle+Kotlin Project [ Download ] [ Source Code ] Kos is mostly written in Java and carefully designed to be easily integrated other JVM languages like Kotlin and Scala. To import Kos you should include the following libraries on your project. Gradle (kts) dependencies { // Import the Bill of Materials implementation ( platform ( \"io.skullabs.kos:kos-bom: ${ version_kos } \" )) implementation ( \"io.skullabs.kos:kos-core\" ) compileOnly ( \"io.skullabs.kos:kos-annotations\" ) } Maven (pom.kts) dependencyManagement { dependencies { // Import the Bill of Materials import ( \"io.skullabs.kos:kos-bom: ${ kosVersion } \" ) } } dependencies { // Kos Dependencies compile ( \"io.skullabs.kos:kos-core\" ) compile ( \"io.skullabs.kos:kos-injector\" ) provided ( \"io.skullabs.kos:kos-annotations\" ) } Maven (pom.xml) <dependencyManagement> <dependencies> <!-- Import the Bill of Materials --> <dependency> <groupId> io.skullabs.kos </groupId> <artifactId> kos-bom </artifactId> <version> ${version_kos} </version> <type> pom </type> <scope> import </scope> </dependency> </dependencies> </dependencyManagement> <dependencies> <dependency> <groupId> io.skullabs.kos </groupId> <artifactId> kos-core </artifactId> </dependency> <dependency> <groupId> io.skullabs.kos </groupId> <artifactId> kos-annotations </artifactId> </dependency> </dependency> Now let's create a simple HelloWorld API. Kotlin @Path ( \"hello\" ) class HelloWorldApi { @GET ( \"world\" ) fun sayHello () = \"Hello World\" } Java @Path ( \"hello\" ) class HelloWorldApi { @GET ( \"world\" ) String sayHello () { return \"Hello World\" ; } } Finally, we have to bundle all dependencies together and generate a runnable jar with them. Gradle (kts) // You can use either Shadow or VertX plugin to generate a fat jar // We've picked VertX in this example plugins { id ( \"io.vertx.vertx-plugin\" ) version \"1.2.0\" } vertx { launcher = launcherClass } Maven (pom.kts) plugins { plugin ( \"org.apache.maven.plugins:maven-shade-plugin:3.2.0\" ) { executions { execution ( id = \"default-package\" , phase = \"package\" , goals = listOf ( \"shade\" )) } configuration { \"createDependencyReducedPom\" to true \"dependencyReducedPomLocation\" to \"\\ ${ project . build . directory } /pom-reduced.xml\" \"transformers\" { \"org.apache.maven.plugins.shade.resource.ServicesResourceTransformer\" {} \"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\" { \"manifestEntries\" { \"Main-Class\" to launcherClass } } } } } } Maven (pom.xml) <plugin> <artifactId> maven-shade-plugin </artifactId> <version> 3.2.0 </version> <executions> <execution> <id> default-package </id> <phase> package </phase> <goals> <goal> shade </goal> </goals> <configuration> <createDependencyReducedPom> true </createDependencyReducedPom> <dependencyReducedPomLocation> ${project.build.directory}/pom-reduced.xml </dependencyReducedPomLocation> <transformers> <org.apache.maven.plugins.shade.resource.ServicesResourceTransformer /> <org.apache.maven.plugins.shade.resource.ManifestResourceTransformer> <manifestEntries> <Main-Class> kos.core.Launcher </Main-Class> </manifestEntries> </org.apache.maven.plugins.shade.resource.ManifestResourceTransformer> </transformers> </configuration> </execution> </executions> </plugin> Voila ! Our first Kos software is ready. Let's run it? Gradle $ java -jar build/libs/my-kos-app-all.jar Maven $ java -jar target/my-kos-app.jar","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"Info Don't want to follow the following steps by yourself? What about downloading a blueprint project that you can change according to your needs? Gradle+Kotlin Project [ Download ] [ Source Code ] Kos is mostly written in Java and carefully designed to be easily integrated other JVM languages like Kotlin and Scala. To import Kos you should include the following libraries on your project. Gradle (kts) dependencies { // Import the Bill of Materials implementation ( platform ( \"io.skullabs.kos:kos-bom: ${ version_kos } \" )) implementation ( \"io.skullabs.kos:kos-core\" ) compileOnly ( \"io.skullabs.kos:kos-annotations\" ) } Maven (pom.kts) dependencyManagement { dependencies { // Import the Bill of Materials import ( \"io.skullabs.kos:kos-bom: ${ kosVersion } \" ) } } dependencies { // Kos Dependencies compile ( \"io.skullabs.kos:kos-core\" ) compile ( \"io.skullabs.kos:kos-injector\" ) provided ( \"io.skullabs.kos:kos-annotations\" ) } Maven (pom.xml) <dependencyManagement> <dependencies> <!-- Import the Bill of Materials --> <dependency> <groupId> io.skullabs.kos </groupId> <artifactId> kos-bom </artifactId> <version> ${version_kos} </version> <type> pom </type> <scope> import </scope> </dependency> </dependencies> </dependencyManagement> <dependencies> <dependency> <groupId> io.skullabs.kos </groupId> <artifactId> kos-core </artifactId> </dependency> <dependency> <groupId> io.skullabs.kos </groupId> <artifactId> kos-annotations </artifactId> </dependency> </dependency> Now let's create a simple HelloWorld API. Kotlin @Path ( \"hello\" ) class HelloWorldApi { @GET ( \"world\" ) fun sayHello () = \"Hello World\" } Java @Path ( \"hello\" ) class HelloWorldApi { @GET ( \"world\" ) String sayHello () { return \"Hello World\" ; } } Finally, we have to bundle all dependencies together and generate a runnable jar with them. Gradle (kts) // You can use either Shadow or VertX plugin to generate a fat jar // We've picked VertX in this example plugins { id ( \"io.vertx.vertx-plugin\" ) version \"1.2.0\" } vertx { launcher = launcherClass } Maven (pom.kts) plugins { plugin ( \"org.apache.maven.plugins:maven-shade-plugin:3.2.0\" ) { executions { execution ( id = \"default-package\" , phase = \"package\" , goals = listOf ( \"shade\" )) } configuration { \"createDependencyReducedPom\" to true \"dependencyReducedPomLocation\" to \"\\ ${ project . build . directory } /pom-reduced.xml\" \"transformers\" { \"org.apache.maven.plugins.shade.resource.ServicesResourceTransformer\" {} \"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\" { \"manifestEntries\" { \"Main-Class\" to launcherClass } } } } } } Maven (pom.xml) <plugin> <artifactId> maven-shade-plugin </artifactId> <version> 3.2.0 </version> <executions> <execution> <id> default-package </id> <phase> package </phase> <goals> <goal> shade </goal> </goals> <configuration> <createDependencyReducedPom> true </createDependencyReducedPom> <dependencyReducedPomLocation> ${project.build.directory}/pom-reduced.xml </dependencyReducedPomLocation> <transformers> <org.apache.maven.plugins.shade.resource.ServicesResourceTransformer /> <org.apache.maven.plugins.shade.resource.ManifestResourceTransformer> <manifestEntries> <Main-Class> kos.core.Launcher </Main-Class> </manifestEntries> </org.apache.maven.plugins.shade.resource.ManifestResourceTransformer> </transformers> </configuration> </execution> </executions> </plugin> Voila ! Our first Kos software is ready. Let's run it? Gradle $ java -jar build/libs/my-kos-app-all.jar Maven $ java -jar target/my-kos-app.jar","title":"Getting Started"},{"location":"license/","text":"License Copyright 2018-2021 Skullabs Contributors. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"license/#license","text":"Copyright 2018-2021 Skullabs Contributors. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"manual/architecture/implementation-loaders/","text":"Implementation Loaders Internally, Kos refers to Dependency Injection mechanisms as Implementation Loaders . They are responsible to perform two basic tasks the Kos needs all the time: Load an object implementing a given Interface - or extending a given class Load all objects implementing a given Interface - or extending a given class Bear in mind that dependencies are lazy loaded, once a dependency for a given type is loaded you can't override it. This means that you can safely read any injected dependency using KosContext. However, the only place you should be able to deterministically modify these dependencies is within a Plugin scope. Types of Implementation Loaders The next topics will cover all DI mechanism provided out-of-box with Kos. Injector Injector is lightweight and zero-overhead, dependency injection library for JVM developers. It was carefully designed to make no-use of reflection by having all required meta-information computed at compile time. At runtime, it performs only the necessary tasks required to instantiate classes and have its dependencies injected. The result is a blistering fast Dependency Injection implementation that has around 7kb of footprint. To provide an implementation of a given Kos service, all you have to do is implement a given interface (or extend a given class) and annotate with injector.Exposed annotation. Also, to make ordinary classes able to be managed by Injector you should annotate them with either injector.Singleton or injector.New . Info For more details on how Injector works, please proceed to its documentation . Below you can find a Custom Exception Handler implementation. import injector.Exposed ; import kos.api.ExceptionHandler ; import kos.api.Response ; @ExposedAs ( ExceptionHandler . class ) public class CustomExceptionHandler implements ExceptionHandler { public Response handle ( RoutingContext request , Throwable cause ){ if ( cause instanceof IllegalArgumentException ) return Response . BAD_REQUEST ; return Response . of ( cause . getMessage ()). statusCode ( 500 ); } } To use Injector as default Implementation Loader you need to import kos-injector module on your project. Gradle (kts) implementation ( \"io.skullabs.kos:kos-injector\" ) Maven (pom.kts) compile ( \"io.skullabs.kos:kos-injector\" ) Maven (pom.xml) <dependency> <groupId> io.skullabs.kos </groupId> <artifactId> kos-injector </artifactId> </dependency> Custom Dependency Injection Mechanism As mentioned before, the Implementation Loader is a simple mechanism and doesn't enforce you to stick with a single implementation. To provide your own Implementation Loader you need to implement the kos.api.ImplementationLoader interface. Once you've implemented you need to register it as the default Implementation Loader by exposing it as Service Provider implementation. You can do so by creating a META-INF/services/kos.api.ImplementationLoader file containing the canonical name of your just created class.","title":"Implementation Loaders"},{"location":"manual/architecture/implementation-loaders/#implementation-loaders","text":"Internally, Kos refers to Dependency Injection mechanisms as Implementation Loaders . They are responsible to perform two basic tasks the Kos needs all the time: Load an object implementing a given Interface - or extending a given class Load all objects implementing a given Interface - or extending a given class Bear in mind that dependencies are lazy loaded, once a dependency for a given type is loaded you can't override it. This means that you can safely read any injected dependency using KosContext. However, the only place you should be able to deterministically modify these dependencies is within a Plugin scope.","title":"Implementation Loaders"},{"location":"manual/architecture/implementation-loaders/#types-of-implementation-loaders","text":"The next topics will cover all DI mechanism provided out-of-box with Kos.","title":"Types of Implementation Loaders"},{"location":"manual/architecture/implementation-loaders/#injector","text":"Injector is lightweight and zero-overhead, dependency injection library for JVM developers. It was carefully designed to make no-use of reflection by having all required meta-information computed at compile time. At runtime, it performs only the necessary tasks required to instantiate classes and have its dependencies injected. The result is a blistering fast Dependency Injection implementation that has around 7kb of footprint. To provide an implementation of a given Kos service, all you have to do is implement a given interface (or extend a given class) and annotate with injector.Exposed annotation. Also, to make ordinary classes able to be managed by Injector you should annotate them with either injector.Singleton or injector.New . Info For more details on how Injector works, please proceed to its documentation . Below you can find a Custom Exception Handler implementation. import injector.Exposed ; import kos.api.ExceptionHandler ; import kos.api.Response ; @ExposedAs ( ExceptionHandler . class ) public class CustomExceptionHandler implements ExceptionHandler { public Response handle ( RoutingContext request , Throwable cause ){ if ( cause instanceof IllegalArgumentException ) return Response . BAD_REQUEST ; return Response . of ( cause . getMessage ()). statusCode ( 500 ); } } To use Injector as default Implementation Loader you need to import kos-injector module on your project. Gradle (kts) implementation ( \"io.skullabs.kos:kos-injector\" ) Maven (pom.kts) compile ( \"io.skullabs.kos:kos-injector\" ) Maven (pom.xml) <dependency> <groupId> io.skullabs.kos </groupId> <artifactId> kos-injector </artifactId> </dependency>","title":"Injector"},{"location":"manual/architecture/implementation-loaders/#custom-dependency-injection-mechanism","text":"As mentioned before, the Implementation Loader is a simple mechanism and doesn't enforce you to stick with a single implementation. To provide your own Implementation Loader you need to implement the kos.api.ImplementationLoader interface. Once you've implemented you need to register it as the default Implementation Loader by exposing it as Service Provider implementation. You can do so by creating a META-INF/services/kos.api.ImplementationLoader file containing the canonical name of your just created class.","title":"Custom Dependency Injection Mechanism"},{"location":"manual/architecture/internal-events/","text":"Internal Events Kos triggers a few events during the application bootstrap. It might be particularly useful to customize how Vert.x will behave internally, allowing developers to deploy custom verticles or even changing Kos' default configuration parameters. Web Server events By exposing an implementation of the interface kos.api.WebServerEventListener , your code will be notified before the web server is instantiated and its routes are deployed. This might be useful to deploy custom routes, or tweaking the web server nobs to your needs. Note : this event won't be triggered if the default WebServer verticle is turned off. Kotlin @Exposed class MyWebListener : WebServerEventListener { fun on ( event : BeforeDeployWebServerEvent ) { TODO ( \"Implement me!\" ) } } Java @Exposed class MyWebListener implements WebServerEventListener { public void on ( BeforeDeployWebServerEvent event ) { throw new UnsupportedOperationException ( \"Implement me!\" ); } } Configuration Loaded events By exposing an implementation of the interface kos.api.ConfigurationLoadedListener , developers will be notified whenever the whole application is about to be started. It allow one to read the whole configuration of the software. Kotlin @Exposed class MyCustomAppBootstrap : ConfigurationLoadedEventListener { fun on ( event : ConfigurationLoadedEvent ) { TODO ( \"Implement me!\" ) } } Java @Exposed class MyCustomAppBootstrap implements ConfigurationLoadedEventListener { public void on ( ConfigurationLoadedEventListener event ) { throw new UnsupportedOperationException ( \"Implement me!\" ); } }","title":"Internal Events"},{"location":"manual/architecture/internal-events/#internal-events","text":"Kos triggers a few events during the application bootstrap. It might be particularly useful to customize how Vert.x will behave internally, allowing developers to deploy custom verticles or even changing Kos' default configuration parameters.","title":"Internal Events"},{"location":"manual/architecture/internal-events/#web-server-events","text":"By exposing an implementation of the interface kos.api.WebServerEventListener , your code will be notified before the web server is instantiated and its routes are deployed. This might be useful to deploy custom routes, or tweaking the web server nobs to your needs. Note : this event won't be triggered if the default WebServer verticle is turned off. Kotlin @Exposed class MyWebListener : WebServerEventListener { fun on ( event : BeforeDeployWebServerEvent ) { TODO ( \"Implement me!\" ) } } Java @Exposed class MyWebListener implements WebServerEventListener { public void on ( BeforeDeployWebServerEvent event ) { throw new UnsupportedOperationException ( \"Implement me!\" ); } }","title":"Web Server events"},{"location":"manual/architecture/internal-events/#configuration-loaded-events","text":"By exposing an implementation of the interface kos.api.ConfigurationLoadedListener , developers will be notified whenever the whole application is about to be started. It allow one to read the whole configuration of the software. Kotlin @Exposed class MyCustomAppBootstrap : ConfigurationLoadedEventListener { fun on ( event : ConfigurationLoadedEvent ) { TODO ( \"Implement me!\" ) } } Java @Exposed class MyCustomAppBootstrap implements ConfigurationLoadedEventListener { public void on ( ConfigurationLoadedEventListener event ) { throw new UnsupportedOperationException ( \"Implement me!\" ); } }","title":"Configuration Loaded events"},{"location":"manual/architecture/kos-context/","text":"The Kos Context kos.api.KosContext is the backbone of the system, containing all the basic components in which Kos will interact with. To avoid misconfiguration, there will be only one instance of this object (managed by Kos) in the whole application. The only way to mutate its content is by creating a Plugin . Things you can do with it Programmatically access injectable dependencies - By invoking KosContext.getImplementationLoader() you will be able to directly interact with all injectable dependencies found at compile time . If you have access to a MutableKosContext instance, you will also be able to define a customised dependency injection framework - replacing Injector completely. Use a different serialization strategy - By default, just as any other web server, Kos will always respect the HTTP Headers to infer which type of serialization to use when handling a Http Request. You can change this by passing your own PayloadSerialisationStrategy implementation to MutableKosContext.setPayloadSerializationStrategy . Change the default payload serializer - When using the default serialization strategy, Kos will use JSON as default serializer whenever the response Content-Type is not defined or the Context-Type header is not present in the request. You can use the MutableKosContext.setDefaultSerializer to modify the serialization type. For more details, check the KosContext and MutableKosContext javadoc.","title":"Kos Context"},{"location":"manual/architecture/kos-context/#the-kos-context","text":"kos.api.KosContext is the backbone of the system, containing all the basic components in which Kos will interact with. To avoid misconfiguration, there will be only one instance of this object (managed by Kos) in the whole application. The only way to mutate its content is by creating a Plugin .","title":"The Kos Context"},{"location":"manual/architecture/kos-context/#things-you-can-do-with-it","text":"Programmatically access injectable dependencies - By invoking KosContext.getImplementationLoader() you will be able to directly interact with all injectable dependencies found at compile time . If you have access to a MutableKosContext instance, you will also be able to define a customised dependency injection framework - replacing Injector completely. Use a different serialization strategy - By default, just as any other web server, Kos will always respect the HTTP Headers to infer which type of serialization to use when handling a Http Request. You can change this by passing your own PayloadSerialisationStrategy implementation to MutableKosContext.setPayloadSerializationStrategy . Change the default payload serializer - When using the default serialization strategy, Kos will use JSON as default serializer whenever the response Content-Type is not defined or the Context-Type header is not present in the request. You can use the MutableKosContext.setDefaultSerializer to modify the serialization type. For more details, check the KosContext and MutableKosContext javadoc.","title":"Things you can do with it"},{"location":"manual/architecture/kos-plugins/","text":"Kos Plugins Kos Plugins are useful to change how any internal component will work, being it provided by Kos itself or a Vert.x one. Plugins are the only entrypoint that allows developers to mutate kos.api.KosContext (through kos.api.MutableKosContext ). To learn more about KosContext, check this page . Creating a Plugin Creating a plugin is easy. All it's needed is exposing an implementation of the interface kos.api.Plugin and you will have access to a mutable instance of kos.api.KosContext . Kotlin @Exposed class MyWebListener : Plugin { fun configure ( kosContext : MutableKosContext ) { TODO ( \"Implement me!\" ) } } Java @Exposed class MyWebListener implements Plugin { public void configure ( MutableKosContext kosContext ) { throw new UnsupportedOperationException ( \"Implement me!\" ); } }","title":"Plugins"},{"location":"manual/architecture/kos-plugins/#kos-plugins","text":"Kos Plugins are useful to change how any internal component will work, being it provided by Kos itself or a Vert.x one. Plugins are the only entrypoint that allows developers to mutate kos.api.KosContext (through kos.api.MutableKosContext ). To learn more about KosContext, check this page .","title":"Kos Plugins"},{"location":"manual/architecture/kos-plugins/#creating-a-plugin","text":"Creating a plugin is easy. All it's needed is exposing an implementation of the interface kos.api.Plugin and you will have access to a mutable instance of kos.api.KosContext . Kotlin @Exposed class MyWebListener : Plugin { fun configure ( kosContext : MutableKosContext ) { TODO ( \"Implement me!\" ) } } Java @Exposed class MyWebListener implements Plugin { public void configure ( MutableKosContext kosContext ) { throw new UnsupportedOperationException ( \"Implement me!\" ); } }","title":"Creating a Plugin"},{"location":"manual/developer/basic-concepts/","text":"Basic Concepts Kos is just a tiny opinionated layer that wraps all the basic functionality we love from Vert.x behind a simple syntax. In this page we will enumerate the concepts that you need to learn before you use Kos. Annotation Processors Vert.x is rather powerful. It was designed as a toolkit, and can be used to design almost everything. Kos, on the other hand, generates the code that \"glues\" your application layer to Vert.x. This is process happens at compile time through the Annotation Processing Tool provided by the JDK. Dependency Injection Kos makes heavy usa of a tiny Dependency Injection (DI) library called Injector to discover dependencies, configurations and components - becoming the backbone of the whole system. Whenever the server is initialised, Kos will ask Injector for Web Routes, Validators, Event Listeners and other Vert.x components that might have been created during the compilation process. Info You can check the Dependency Injection guide in case you want to a different DI library as a replacement for Injector. Implementation Discovery Most of the Kos components are trivial to be configured. In the process, you might be asked to \"Expose\" an implementation of a given interface, so Kos can find it during the bootstrap process. There are two annotations that can be used to make an interface implementation discoverable (or exposed): injector.Exposed and injector.ExposedAs . ExposedAs is used to explicitly expose the current class as an implementation of a given interface (or superclass) Exposed will expose the current to all interfaces it is directly implementing (ignoring superinterfaces or interfaces implemented by its superclass). Automatically discovered classes As the annotation process takes place, a few classes will be generated making the target class automatically exposed on the Class Path. Classes (or classes which methods are) annotated with the following Kos annotations will be automatically exposed: @RestApi - automatically exposes Rest endpoints @RestClient - automatically exposes Rest clients @Listener - automatically listens for Vert.x's EventBus events @Publisher - automatically publishes Vert.x's EventBus events @Validates - turns a method into an object validator for Event listeners and Rest endpoints The Launcher Kos has a small bootstrap class called kos.core.Launcher that will automatically spin up the server. With a little help from the Implementation Loader , it will read the Vert.x configuration and deploy all verticles found on the class path. So, make sure you set this class as your Main-Class . Kos Context The kos.api.KosContext object contains all the internal components managed by Kos. Among many other features, it holds: io.vertx.core.Vertx instance - used whenever interacting with Vert.x components Log configuration Serialization mechanisms (for both Rest API and Clients) Implementation Loader (Dependency Injection) configuration Default EventBus's MessageCodec for message serialization","title":"Basic Concepts"},{"location":"manual/developer/basic-concepts/#basic-concepts","text":"Kos is just a tiny opinionated layer that wraps all the basic functionality we love from Vert.x behind a simple syntax. In this page we will enumerate the concepts that you need to learn before you use Kos.","title":"Basic Concepts"},{"location":"manual/developer/basic-concepts/#annotation-processors","text":"Vert.x is rather powerful. It was designed as a toolkit, and can be used to design almost everything. Kos, on the other hand, generates the code that \"glues\" your application layer to Vert.x. This is process happens at compile time through the Annotation Processing Tool provided by the JDK.","title":"Annotation Processors"},{"location":"manual/developer/basic-concepts/#dependency-injection","text":"Kos makes heavy usa of a tiny Dependency Injection (DI) library called Injector to discover dependencies, configurations and components - becoming the backbone of the whole system. Whenever the server is initialised, Kos will ask Injector for Web Routes, Validators, Event Listeners and other Vert.x components that might have been created during the compilation process. Info You can check the Dependency Injection guide in case you want to a different DI library as a replacement for Injector.","title":"Dependency Injection"},{"location":"manual/developer/basic-concepts/#implementation-discovery","text":"Most of the Kos components are trivial to be configured. In the process, you might be asked to \"Expose\" an implementation of a given interface, so Kos can find it during the bootstrap process. There are two annotations that can be used to make an interface implementation discoverable (or exposed): injector.Exposed and injector.ExposedAs . ExposedAs is used to explicitly expose the current class as an implementation of a given interface (or superclass) Exposed will expose the current to all interfaces it is directly implementing (ignoring superinterfaces or interfaces implemented by its superclass).","title":"Implementation Discovery"},{"location":"manual/developer/basic-concepts/#automatically-discovered-classes","text":"As the annotation process takes place, a few classes will be generated making the target class automatically exposed on the Class Path. Classes (or classes which methods are) annotated with the following Kos annotations will be automatically exposed: @RestApi - automatically exposes Rest endpoints @RestClient - automatically exposes Rest clients @Listener - automatically listens for Vert.x's EventBus events @Publisher - automatically publishes Vert.x's EventBus events @Validates - turns a method into an object validator for Event listeners and Rest endpoints","title":"Automatically discovered classes"},{"location":"manual/developer/basic-concepts/#the-launcher","text":"Kos has a small bootstrap class called kos.core.Launcher that will automatically spin up the server. With a little help from the Implementation Loader , it will read the Vert.x configuration and deploy all verticles found on the class path. So, make sure you set this class as your Main-Class .","title":"The Launcher"},{"location":"manual/developer/basic-concepts/#kos-context","text":"The kos.api.KosContext object contains all the internal components managed by Kos. Among many other features, it holds: io.vertx.core.Vertx instance - used whenever interacting with Vert.x components Log configuration Serialization mechanisms (for both Rest API and Clients) Implementation Loader (Dependency Injection) configuration Default EventBus's MessageCodec for message serialization","title":"Kos Context"},{"location":"manual/developer/config-files/","text":"Reading Configuration File As stated by its documentation , Vert.x provides the vertx-config module to efficiently interact with configuration files. Internally, this module relies on the Config Retriever and Configuration store concepts, defining \"a location from where the configuration data is read and also a format (JSON by default).\" As an attempt to simplify this process, Kos made the following design choices: it only looks after files named application.yml in the classpath. In case more than one is found, they will be merged before being used. it fully executes the above by default, but allows one to change the default behaviour (e.g. using a different Configuration Retriever ) Once the configuration is read, you will have access to an JsonObject - just like you'd have on a typical Vert.x application. Reading the configuration object The easiest way to interaction with the read configuration would be through Dependency Injection. You will have full access to Kos Context , which will expose the read configuration file (Vert.x's JsonObject ). Kotlin @Singleton class MyServerConfiguration ( private val kosContext : KosContext ) { val dbHost = kosContext . applicationConfig . getString ( \"db.host\" , \"localhost\" ) val dbPort = kosContext . applicationConfig . getString ( \"db.port\" , \"5432\" ) val dbUser = kosContext . applicationConfig . getString ( \"db.user\" , \"postgres\" ) val dbPass = kosContext . applicationConfig . getString ( \"db.pass\" , \"postgres\" ) } Java @Singleton class MyServerConfiguration { private final KosContext kosContext ; public MyServerConfiguration ( KosContext kosContext ){ this . kosContext = kosContext ; } public String getDbHost () { return kosContext . getApplicationConfig (). getString ( \"db.host\" , \"localhost\" ); } public String getDbPort () { return kosContext . getApplicationConfig (). getString ( \"db.port\" , \"5432\" ); } public String getDbUser () { return kosContext . getApplicationConfig (). getString ( \"db.user\" , \"postgres\" ); } public String getDbPass () { return kosContext . getApplicationConfig (). getString ( \"db.pass\" , \"postgres\" ); } } Another option would be listening to Kos' internal events .","title":"Configuration File"},{"location":"manual/developer/config-files/#reading-configuration-file","text":"As stated by its documentation , Vert.x provides the vertx-config module to efficiently interact with configuration files. Internally, this module relies on the Config Retriever and Configuration store concepts, defining \"a location from where the configuration data is read and also a format (JSON by default).\" As an attempt to simplify this process, Kos made the following design choices: it only looks after files named application.yml in the classpath. In case more than one is found, they will be merged before being used. it fully executes the above by default, but allows one to change the default behaviour (e.g. using a different Configuration Retriever ) Once the configuration is read, you will have access to an JsonObject - just like you'd have on a typical Vert.x application.","title":"Reading Configuration File"},{"location":"manual/developer/config-files/#reading-the-configuration-object","text":"The easiest way to interaction with the read configuration would be through Dependency Injection. You will have full access to Kos Context , which will expose the read configuration file (Vert.x's JsonObject ). Kotlin @Singleton class MyServerConfiguration ( private val kosContext : KosContext ) { val dbHost = kosContext . applicationConfig . getString ( \"db.host\" , \"localhost\" ) val dbPort = kosContext . applicationConfig . getString ( \"db.port\" , \"5432\" ) val dbUser = kosContext . applicationConfig . getString ( \"db.user\" , \"postgres\" ) val dbPass = kosContext . applicationConfig . getString ( \"db.pass\" , \"postgres\" ) } Java @Singleton class MyServerConfiguration { private final KosContext kosContext ; public MyServerConfiguration ( KosContext kosContext ){ this . kosContext = kosContext ; } public String getDbHost () { return kosContext . getApplicationConfig (). getString ( \"db.host\" , \"localhost\" ); } public String getDbPort () { return kosContext . getApplicationConfig (). getString ( \"db.port\" , \"5432\" ); } public String getDbUser () { return kosContext . getApplicationConfig (). getString ( \"db.user\" , \"postgres\" ); } public String getDbPass () { return kosContext . getApplicationConfig (). getString ( \"db.pass\" , \"postgres\" ); } } Another option would be listening to Kos' internal events .","title":"Reading the configuration object"},{"location":"manual/developer/event-listeners/","text":"Event Listeners The event bus is the nervous system of Vert.x. It acts as broker, where messages are sent on the event bus to an address . Listeners on these addresses can react to the incoming messages and perform bespoke code (the so-called handlers ). Vert.x supports the following messaging patterns: Publish/Subscribe - This notification pattern allows one to have multiple listeners for each subscription address. The communication happens in uni-directionally from the publisher to all the listeners. Point-to-point - Here messages will be delivered to only one subscriber per address. If multiple listeners are registered, \"one will be chosen to use a non-strict round-robin algorithm. When a message is received by a recipient, and has been handled, the recipient can optionally decide to reply to the message. If they do so, the reply handler will be called\". Kos abstracts the Vertx' EventBus API providing a simple annotation based convention. The simplicity of its design comes at a cost: it only supports the Publish/Subscribe pattern. How Kos Listeners work? Kos abstracts this workflow using the @Listener annotation on a listener method. Here are the restrictions imposed on these methods: it must return either the JVM's void or io.vertx.core.Future<Void> . Future is preferred when performing I/O calls. it must expect exactly one parameter it cannot be a constructor the address defined in the @Listener annotation must not be empty it must not block the Event Loop Here is an example of a listener that listens and consumes for the event UserDeletedEvent . Kotlin @Singleton class UserEventListener { @Listener ( \"user::deleted\" ) fun on ( event : UserDeletedEvent ) { println ( \"User ${ event . userId } has been deleted.\" ) } } Java @Singleton class UserEventListener { @Listener ( \"user::deleted\" ) void on ( UserDeletedEvent event ) { System . out . println ( \"User ${event.userId} has been deleted.\" ) } } Publishing Events Unlike listener methods, publisher methods must only be defined on interface methods. Defined by annotating a method with the @Publisher annotation, Kos will generate a concrete class for your interface. Restrictions: it must return io.vertx.core.Future<Void> , as it will perform an I/O operation it must expect exactly one parameter the address defined in the @Publisher annotation must not be empty it must not block the Event Loop Kotlin interface UserEventPublisher { @Publisher ( \"user::deleted\" ) fun trigger ( event : UserDeletedEvent ) } Java class UserEventPublisher { @Publisher ( \"user::deleted\" ) void trigger ( UserDeletedEvent event ); } Clustering the EventBus Vert.x provides EventBus' clustering capabilities out-of-box. Kos will respect any clustering configuration if you manually define it - this can be achievable by writing a custom Plugin . Bridging EventBus to a remote broker Kos encourage developers to use the Event Listener/Publisher API to communicate with a remote broker (e.g. ApacheMQ, Apache Kafka, AWS SQS, GCP PubSub, etc.). To leverage such capability, Kos provides a Sink mechanism, allowing one to relay the messages to a remote broker and vice-versa. It's comprised of two interfaces - EventPublisherSink and EventSubscriberSink . Here are a few guidelines: Both interfaces will expect EventBusSink.Result as return type. It is expected that Sink classes will choose which address will be handled and which will be ignored. To ignore a given address, one must return EventBusSink.Result.NOT_ATTEMPTED In case of failure, please do not throw an exception. Return EventBusSink.Result.failure(Throwable) instead. If your Sink decides to handle this particular address, make sure to rewrite the original address, creating a dedicated one for each case - one for the listener and one for the producer . The EventSubscriberSink must ensure that any message received from the remote broker will be sent to the newly defined listener address . The EventPublisherSink must ensure that message sent to the newly created producer address will be relayed to the remote broker. The newly created address can be defined by returning EventBusSink.Result.succeededAtAddress(String) . If everything was implemented as expected, @Listener s and @Publisher s methods will transparently communicate with the remote broker.","title":"Event Listeners"},{"location":"manual/developer/event-listeners/#event-listeners","text":"The event bus is the nervous system of Vert.x. It acts as broker, where messages are sent on the event bus to an address . Listeners on these addresses can react to the incoming messages and perform bespoke code (the so-called handlers ). Vert.x supports the following messaging patterns: Publish/Subscribe - This notification pattern allows one to have multiple listeners for each subscription address. The communication happens in uni-directionally from the publisher to all the listeners. Point-to-point - Here messages will be delivered to only one subscriber per address. If multiple listeners are registered, \"one will be chosen to use a non-strict round-robin algorithm. When a message is received by a recipient, and has been handled, the recipient can optionally decide to reply to the message. If they do so, the reply handler will be called\". Kos abstracts the Vertx' EventBus API providing a simple annotation based convention. The simplicity of its design comes at a cost: it only supports the Publish/Subscribe pattern.","title":"Event Listeners"},{"location":"manual/developer/event-listeners/#how-kos-listeners-work","text":"Kos abstracts this workflow using the @Listener annotation on a listener method. Here are the restrictions imposed on these methods: it must return either the JVM's void or io.vertx.core.Future<Void> . Future is preferred when performing I/O calls. it must expect exactly one parameter it cannot be a constructor the address defined in the @Listener annotation must not be empty it must not block the Event Loop Here is an example of a listener that listens and consumes for the event UserDeletedEvent . Kotlin @Singleton class UserEventListener { @Listener ( \"user::deleted\" ) fun on ( event : UserDeletedEvent ) { println ( \"User ${ event . userId } has been deleted.\" ) } } Java @Singleton class UserEventListener { @Listener ( \"user::deleted\" ) void on ( UserDeletedEvent event ) { System . out . println ( \"User ${event.userId} has been deleted.\" ) } }","title":"How Kos Listeners work?"},{"location":"manual/developer/event-listeners/#publishing-events","text":"Unlike listener methods, publisher methods must only be defined on interface methods. Defined by annotating a method with the @Publisher annotation, Kos will generate a concrete class for your interface. Restrictions: it must return io.vertx.core.Future<Void> , as it will perform an I/O operation it must expect exactly one parameter the address defined in the @Publisher annotation must not be empty it must not block the Event Loop Kotlin interface UserEventPublisher { @Publisher ( \"user::deleted\" ) fun trigger ( event : UserDeletedEvent ) } Java class UserEventPublisher { @Publisher ( \"user::deleted\" ) void trigger ( UserDeletedEvent event ); }","title":"Publishing Events"},{"location":"manual/developer/event-listeners/#clustering-the-eventbus","text":"Vert.x provides EventBus' clustering capabilities out-of-box. Kos will respect any clustering configuration if you manually define it - this can be achievable by writing a custom Plugin .","title":"Clustering the EventBus"},{"location":"manual/developer/event-listeners/#bridging-eventbus-to-a-remote-broker","text":"Kos encourage developers to use the Event Listener/Publisher API to communicate with a remote broker (e.g. ApacheMQ, Apache Kafka, AWS SQS, GCP PubSub, etc.). To leverage such capability, Kos provides a Sink mechanism, allowing one to relay the messages to a remote broker and vice-versa. It's comprised of two interfaces - EventPublisherSink and EventSubscriberSink . Here are a few guidelines: Both interfaces will expect EventBusSink.Result as return type. It is expected that Sink classes will choose which address will be handled and which will be ignored. To ignore a given address, one must return EventBusSink.Result.NOT_ATTEMPTED In case of failure, please do not throw an exception. Return EventBusSink.Result.failure(Throwable) instead. If your Sink decides to handle this particular address, make sure to rewrite the original address, creating a dedicated one for each case - one for the listener and one for the producer . The EventSubscriberSink must ensure that any message received from the remote broker will be sent to the newly defined listener address . The EventPublisherSink must ensure that message sent to the newly created producer address will be relayed to the remote broker. The newly created address can be defined by returning EventBusSink.Result.succeededAtAddress(String) . If everything was implemented as expected, @Listener s and @Publisher s methods will transparently communicate with the remote broker.","title":"Bridging EventBus to a remote broker"},{"location":"manual/developer/logging/","text":"Logging Configuration Kos uses SLF4J as main logging implementation. Vert.x internal logging is also automatically configured to use SLF4J as its default logging mechanism. Injecting the logger Kos allows developers to inject SLF4J Loggers into their components. Kotlin import org.slf4j.Logger; @Singleton class MyComponent ( val logger : Logger ) { } Java import org.slf4j.Logger ; @Singleton class MyComponent { Logger logger ; MyComponent ( Logger logger ) { this . logger = logger ; } }","title":"Logging"},{"location":"manual/developer/logging/#logging-configuration","text":"Kos uses SLF4J as main logging implementation. Vert.x internal logging is also automatically configured to use SLF4J as its default logging mechanism.","title":"Logging Configuration"},{"location":"manual/developer/logging/#injecting-the-logger","text":"Kos allows developers to inject SLF4J Loggers into their components. Kotlin import org.slf4j.Logger; @Singleton class MyComponent ( val logger : Logger ) { } Java import org.slf4j.Logger ; @Singleton class MyComponent { Logger logger ; MyComponent ( Logger logger ) { this . logger = logger ; } }","title":"Injecting the logger"},{"location":"manual/developer/rest-apis/","text":"Rest API Write down rest API's with Kos is dead simple and, if you've been using Java ecosystem in the last few years you're probably at home. First, be sure you've included kos-annotations in your compilation Class Path, and double-check if you have enabled APT compilation as well (enabled by default only in Java projects). Gradle (kts) compileOnly ( \"io.skullabs.kos:kos-annotations\" ) Maven (pom.kts) provided ( \"io.skullabs.kos:kos-annotations\" ) Maven (pom.xml) <dependency> <groupId> io.skullabs.kos </groupId> <artifactId> kos-annotations </artifactId> <scope> provided </scope> </dependency> Classes as API entrypoints Kos relies on JVM classes as entrypoint for your APIs. That said, you should identify your class with the kos.rest.RestApi annotation. It will allow Kos to monitor this class for routes. Kotlin import kos.rest.* @RestApi class MyApi { } Java import kos.rest.* ; @RestApi class MyApi { } If your API contains a common root path that could be shared by two or more endpoints, you can set a root path for you API using the RestApi annotation. Kotlin import kos.rest.* @RestApi ( \"/money\" ) class MyApi { } Java import kos.rest.* ; @RestApi ( \"/money\" ) class MyApi { } Exposing Methods as Rest endpoints Out-of-box you can expose any public or package default method as Rest endpoint by using one of the following annotations: kos.rest.GET kos.rest.POST kos.rest.PUT kos.rest.DELETE kos.rest.PATCH Defining URIs for your endpoints Just as kos.rest.RestApi can be used to map a (root) path to an endpoint, the above mentioned annotations can also be used to define a more specific endpoint URI for your methods. In the below example we have two methods exposed as Rest endpoints: MyApi.getMoney will be exposed as GET operation mapped to /money URI. MyApi.getMoreMoney will also be exposed as GET operation, but mapped to /money/double URI. Kotlin import kos.rest.* @RestApi ( \"/money\" ) class MyApi { @GET fun getMoney () = 10 @GET ( \"/double\" ) fun getMoreMoney () = getMoney () * 2 } Java import kos.rest.* ; @RestApi ( \"/money\" ) class MyApi { @GET Integer getMoney (){ return 10 ; } @GET ( \"/double\" ) Integer getMoreMoney (){ return getMoney () * 2 ; } } Sending responses to the Http Client Kos Rest API's will infer the response from the return type defined on your functions: kos.api.Response : this is a special response type bundled in Kos so developers can easily define custom responses to Http Clients. It is particularly useful when you method needs to return different types of Response objects, or different types of Http Status Responses. void : methods that doesn't return a value will make your method API receive the request, perform all the synchronous tasks defined within it and immediately return 204 as default answer. io.vertx.core.Future<?> : by returning Vert.x's Future your Http Clients will wait for the the Future to be completed to receive a response. In case of a success result, the object by the Future instance will be serialized and a successful response will be sent. On the other hand, if your Future holds a failure result, an error message will be sent. Plain Objects: API's that returns plain object will have it's returned object serialized via Default Serializer mechanism and sent as response to your Http Client. How serialization work? Successful responses are automatically serialized through the Default Serializer mechanism. However, in case an exception has been thrown or returned as Future response, the default Exception Handler mechanism will be in charge of converting it into an Http Response. Kotlin import kos.rest.* import io.vertx.core.* import java.util.concurrent.ThreadLocalRandom @RestApi ( \"/money\" ) class MyApi { @GET fun getMoney (): Future < Integer > { val money = Promise . promise () /* * Compute my money. It can be done using any asynchronous operation * as long as you don't block Vert.x's Event Loop. */ return money . future () } @GET ( \"/random\" ) fun getMoreMoney () = return ThreadLocalRandom . current (). nextInt (); @POST fun generateMoney (){ println ( \"This might increase the inflation!\" ) val generated = ThreadLocalRandom . current (). nextInt () println ( \"Generated money: $ $ generated .00\" ); } } Java import kos.rest.* ; import io.vertx.core.* ; import java.util.concurrent.ThreadLocalRandom ; @RestApi ( \"/money\" ) class MyApi { @GET Future < Integer > getMoney (){ Promise < Integer > money = Promise . promise (); /* * Compute my money. It can be done using any asynchronous operation * as long as you don't block Vert.x's Event Loop. */ return money . future (); } @GET ( \"/random\" ) Integer getMoreMoney (){ return ThreadLocalRandom . current (). nextInt (); } @POST void generateMoney (){ System . err . println ( \"This might increase the inflation!\" ); int generated = ThreadLocalRandom . current (). nextInt (); System . out . println ( \"Generated money: $\" + generated + \".00\" ); } } URI Mapping Conventions As Kos don't replace Vert.x's routing mechanism, but only automates its creation, you still can take full advantage of it when using Kos' annotation. You can use: fixed defined paths - with no placeholders or wildcard marks. e.g. /some/path/ paths that begins with something - e.g. /some/path/* paths with variable placeholders - e.g. /catalogue/products/:producttype/:productid/ It is worth notice though that it doesn't support RegEx mapping though. Capturing parameters The following sub-topics will describe how to capture parameters received from the Http Client (e.g. path parameters) in your Rest endpoint method. Vert.x core expects parameters to be either CharSequence or String . To automatically they will be converted into the desired type by the String Converter Mechanism beforehand, making these values available for developers transparently. A few rules apply though: You have to define the placeholder name you are willing to use If you haven't defined the parameter name, the parameter variable name will be used instead If the defined name doesn't match any existing placeholder, an Exception might be thrown If you have defined a complex object for you captured parameter, and no converter has been defined to that given type, an Exception might be thrown. Path Parameters All the matched path placeholders can be easily mapped as parameters in your just created method by using the kos.rest.Path annotation. Kotlin import kos.rest.* @RestApi class MyApi { @GET ( \"/calc/number/:a\" ) fun getMoney ( @Param a : String ) = a @POST ( \"/calc/plus/:a/:b\" ) fun generateMoney ( @Param ( \"a\" ) first : Int , @Param ( \"b\" ) second : Int ) = first + second } Java import kos.rest.* ; @RestApi class MyApi { @GET ( \"/calc/number/:a\" ) Integer getMoney ( @Param Integer a ){ return a ; } @POST ( \"/calc/plus/:a/:b\" ) Integer generateMoney ( @Param ( \"a\" ) Integer first , @Param ( \"b\" ) Integer second ) { return first + second ; } } Query parameters As Vert.x treats query parameters and paths similarly (both being accessible via io.vertx.core.http.HttpServerRequest.getParam(String) ), you can use the same kos.rest.Path to capture query strings as well. Http Headers Similarly to path and query parameters, we can capture headers send by the Http Client by using the kos.rest.Header annotation. Kotlin import kos.rest.* @RestApi class MyApi { @GET ( \"/what-is-my-user-agent\" ) fun whatIsMyUserAgent ( @Param ( \"Content-Type\" ) contentType : String ) = contentType } Java import kos.rest.* ; @RestApi class MyApi { @GET ( \"/what-is-my-user-agent\" ) String whatIsMyUserAgent ( @Param ( \"Content-Type\" ) String contentType ) { return contentType ; } } Capturing the request payload As you might imagine, similarly to capturing other params you can capture the request payload sent in the Http Request's body using an annotation. In this case, it will be kos.rest.Body . Unlike other parameters though, payloads will be converted into an object by the default Serializer Mechanism configured on your application. Kotlin import kos.rest.* @RestApi class MyApi { @POST ( \"/money\" ) fun sendMoney ( @Body request : SendMoneyRequest ) = \" ${ request . to } has received $ ${ request . amount } \" } data class SendMoneyRequest ( val to : String , val amount : Double ) Java import kos.rest.* ; @RestApi class MyApi { @POST ( \"/money\" ) String sendMoney ( @Body SendMoneyRequest request ) { return request . to \" has received $\" + request . amount ; } } class SendMoneyRequest { String to ; Double amount ; // getters and setters }","title":"Rest API"},{"location":"manual/developer/rest-apis/#rest-api","text":"Write down rest API's with Kos is dead simple and, if you've been using Java ecosystem in the last few years you're probably at home. First, be sure you've included kos-annotations in your compilation Class Path, and double-check if you have enabled APT compilation as well (enabled by default only in Java projects). Gradle (kts) compileOnly ( \"io.skullabs.kos:kos-annotations\" ) Maven (pom.kts) provided ( \"io.skullabs.kos:kos-annotations\" ) Maven (pom.xml) <dependency> <groupId> io.skullabs.kos </groupId> <artifactId> kos-annotations </artifactId> <scope> provided </scope> </dependency>","title":"Rest API"},{"location":"manual/developer/rest-apis/#classes-as-api-entrypoints","text":"Kos relies on JVM classes as entrypoint for your APIs. That said, you should identify your class with the kos.rest.RestApi annotation. It will allow Kos to monitor this class for routes. Kotlin import kos.rest.* @RestApi class MyApi { } Java import kos.rest.* ; @RestApi class MyApi { } If your API contains a common root path that could be shared by two or more endpoints, you can set a root path for you API using the RestApi annotation. Kotlin import kos.rest.* @RestApi ( \"/money\" ) class MyApi { } Java import kos.rest.* ; @RestApi ( \"/money\" ) class MyApi { }","title":"Classes as API entrypoints"},{"location":"manual/developer/rest-apis/#exposing-methods-as-rest-endpoints","text":"Out-of-box you can expose any public or package default method as Rest endpoint by using one of the following annotations: kos.rest.GET kos.rest.POST kos.rest.PUT kos.rest.DELETE kos.rest.PATCH","title":"Exposing Methods as Rest endpoints"},{"location":"manual/developer/rest-apis/#defining-uris-for-your-endpoints","text":"Just as kos.rest.RestApi can be used to map a (root) path to an endpoint, the above mentioned annotations can also be used to define a more specific endpoint URI for your methods. In the below example we have two methods exposed as Rest endpoints: MyApi.getMoney will be exposed as GET operation mapped to /money URI. MyApi.getMoreMoney will also be exposed as GET operation, but mapped to /money/double URI. Kotlin import kos.rest.* @RestApi ( \"/money\" ) class MyApi { @GET fun getMoney () = 10 @GET ( \"/double\" ) fun getMoreMoney () = getMoney () * 2 } Java import kos.rest.* ; @RestApi ( \"/money\" ) class MyApi { @GET Integer getMoney (){ return 10 ; } @GET ( \"/double\" ) Integer getMoreMoney (){ return getMoney () * 2 ; } }","title":"Defining URIs for your endpoints"},{"location":"manual/developer/rest-apis/#sending-responses-to-the-http-client","text":"Kos Rest API's will infer the response from the return type defined on your functions: kos.api.Response : this is a special response type bundled in Kos so developers can easily define custom responses to Http Clients. It is particularly useful when you method needs to return different types of Response objects, or different types of Http Status Responses. void : methods that doesn't return a value will make your method API receive the request, perform all the synchronous tasks defined within it and immediately return 204 as default answer. io.vertx.core.Future<?> : by returning Vert.x's Future your Http Clients will wait for the the Future to be completed to receive a response. In case of a success result, the object by the Future instance will be serialized and a successful response will be sent. On the other hand, if your Future holds a failure result, an error message will be sent. Plain Objects: API's that returns plain object will have it's returned object serialized via Default Serializer mechanism and sent as response to your Http Client. How serialization work? Successful responses are automatically serialized through the Default Serializer mechanism. However, in case an exception has been thrown or returned as Future response, the default Exception Handler mechanism will be in charge of converting it into an Http Response. Kotlin import kos.rest.* import io.vertx.core.* import java.util.concurrent.ThreadLocalRandom @RestApi ( \"/money\" ) class MyApi { @GET fun getMoney (): Future < Integer > { val money = Promise . promise () /* * Compute my money. It can be done using any asynchronous operation * as long as you don't block Vert.x's Event Loop. */ return money . future () } @GET ( \"/random\" ) fun getMoreMoney () = return ThreadLocalRandom . current (). nextInt (); @POST fun generateMoney (){ println ( \"This might increase the inflation!\" ) val generated = ThreadLocalRandom . current (). nextInt () println ( \"Generated money: $ $ generated .00\" ); } } Java import kos.rest.* ; import io.vertx.core.* ; import java.util.concurrent.ThreadLocalRandom ; @RestApi ( \"/money\" ) class MyApi { @GET Future < Integer > getMoney (){ Promise < Integer > money = Promise . promise (); /* * Compute my money. It can be done using any asynchronous operation * as long as you don't block Vert.x's Event Loop. */ return money . future (); } @GET ( \"/random\" ) Integer getMoreMoney (){ return ThreadLocalRandom . current (). nextInt (); } @POST void generateMoney (){ System . err . println ( \"This might increase the inflation!\" ); int generated = ThreadLocalRandom . current (). nextInt (); System . out . println ( \"Generated money: $\" + generated + \".00\" ); } }","title":"Sending responses to the Http Client"},{"location":"manual/developer/rest-apis/#uri-mapping-conventions","text":"As Kos don't replace Vert.x's routing mechanism, but only automates its creation, you still can take full advantage of it when using Kos' annotation. You can use: fixed defined paths - with no placeholders or wildcard marks. e.g. /some/path/ paths that begins with something - e.g. /some/path/* paths with variable placeholders - e.g. /catalogue/products/:producttype/:productid/ It is worth notice though that it doesn't support RegEx mapping though.","title":"URI Mapping Conventions"},{"location":"manual/developer/rest-apis/#capturing-parameters","text":"The following sub-topics will describe how to capture parameters received from the Http Client (e.g. path parameters) in your Rest endpoint method. Vert.x core expects parameters to be either CharSequence or String . To automatically they will be converted into the desired type by the String Converter Mechanism beforehand, making these values available for developers transparently. A few rules apply though: You have to define the placeholder name you are willing to use If you haven't defined the parameter name, the parameter variable name will be used instead If the defined name doesn't match any existing placeholder, an Exception might be thrown If you have defined a complex object for you captured parameter, and no converter has been defined to that given type, an Exception might be thrown.","title":"Capturing parameters"},{"location":"manual/developer/rest-apis/#path-parameters","text":"All the matched path placeholders can be easily mapped as parameters in your just created method by using the kos.rest.Path annotation. Kotlin import kos.rest.* @RestApi class MyApi { @GET ( \"/calc/number/:a\" ) fun getMoney ( @Param a : String ) = a @POST ( \"/calc/plus/:a/:b\" ) fun generateMoney ( @Param ( \"a\" ) first : Int , @Param ( \"b\" ) second : Int ) = first + second } Java import kos.rest.* ; @RestApi class MyApi { @GET ( \"/calc/number/:a\" ) Integer getMoney ( @Param Integer a ){ return a ; } @POST ( \"/calc/plus/:a/:b\" ) Integer generateMoney ( @Param ( \"a\" ) Integer first , @Param ( \"b\" ) Integer second ) { return first + second ; } }","title":"Path Parameters"},{"location":"manual/developer/rest-apis/#query-parameters","text":"As Vert.x treats query parameters and paths similarly (both being accessible via io.vertx.core.http.HttpServerRequest.getParam(String) ), you can use the same kos.rest.Path to capture query strings as well.","title":"Query parameters"},{"location":"manual/developer/rest-apis/#http-headers","text":"Similarly to path and query parameters, we can capture headers send by the Http Client by using the kos.rest.Header annotation. Kotlin import kos.rest.* @RestApi class MyApi { @GET ( \"/what-is-my-user-agent\" ) fun whatIsMyUserAgent ( @Param ( \"Content-Type\" ) contentType : String ) = contentType } Java import kos.rest.* ; @RestApi class MyApi { @GET ( \"/what-is-my-user-agent\" ) String whatIsMyUserAgent ( @Param ( \"Content-Type\" ) String contentType ) { return contentType ; } }","title":"Http Headers"},{"location":"manual/developer/rest-apis/#capturing-the-request-payload","text":"As you might imagine, similarly to capturing other params you can capture the request payload sent in the Http Request's body using an annotation. In this case, it will be kos.rest.Body . Unlike other parameters though, payloads will be converted into an object by the default Serializer Mechanism configured on your application. Kotlin import kos.rest.* @RestApi class MyApi { @POST ( \"/money\" ) fun sendMoney ( @Body request : SendMoneyRequest ) = \" ${ request . to } has received $ ${ request . amount } \" } data class SendMoneyRequest ( val to : String , val amount : Double ) Java import kos.rest.* ; @RestApi class MyApi { @POST ( \"/money\" ) String sendMoney ( @Body SendMoneyRequest request ) { return request . to \" has received $\" + request . amount ; } } class SendMoneyRequest { String to ; Double amount ; // getters and setters }","title":"Capturing the request payload"},{"location":"manual/developer/rest-clients/","text":"Rest Clients Write down rest clients is usually a task most people don't like to do, especially in the JVM ecosystem. We have several Http abstractions and implementations, each of them with different dependency stack. Vert.x team introduced a web client API on their vertx-web module, which is managed by vertx-core connection pool for optimal resource utilization. By borrowing a few ideas from Netflix Feign and other well known open source frameworks, Kos provides a simple API to create Rest Clients that takes advantage of the well crafted vertx-web module. It is behaves similarly to the Rest API: it uses the same annotations as the Rest Api to map endpoints to methods the same applies when mapping path parameters , query parameters or headers to method parameters it also uses the same Body annotation to serialize and send request payloads Interfaces as API entrypoint The biggest difference lies on the fact that you don't write concrete classes to define your Rest Clients, you write interfaces. You also have to annotate them with kos.rest.RestClient instead of the kos.core.RestApi one. Kotlin import kos.rest.* @RestClient ( \"/calc\" ) interface CalculatorApiClient { @GET ( \"/plus/:a/:b\" ) fun plus ( @Param a : Int , @Param b : Int ): Future < Int > @GET ( \"/minus/:a/:b\" ) fun minus ( @Param a : Int , @Param b : Int ): Future < Int > } Java import kos.rest.* ; @RestClient ( \"/calc\" ) interface CalculatorApiClient { @GET ( \"/plus/:a/:b\" ) Future < Int > plus ( @Param Integer a , @Param Integer b ); @GET ( \"/minus/:a/:b\" ) Future < Int > minus ( @Param Integer a , @Param Integer b ); } Consuming responses to the Http Server Kos Rest Client's will infer the response from the return type defined on your functions: void : methods that doesn't return a value will make the call to the desired API in a fire-and-forget fashion, completely ignoring the response received by the server. io.vertx.core.Future<?> : Http Clients will hold the received response in a Future object allowing you to handle the response asynchronously on your first convenience. As you probably notice, Http Clients never blocks the event loop. This comes with a few restrictions though: You have no automated mechanism to map failures into objects In case of Http responses other than 2xx an Exception ( UnexpectedRestClientResponse ) will be set as future Response allowing you to manually handle the unexpected behavior. Instantiating your Rest Client As the Rest Client API only takes care of mapping endpoints it doesn't know anything else about your client. By using the RestClientFactory.instantiate(RestClientConfiguration, T) method, you can define how it will work, which URL should be used to reach the server, how authentication might work, etc. Kotlin import injector.* import kos.core.client.RestClientConfiguration @Singleton class CalculatorApiClientConfiguration ( val restClientFactory : RestClientFactory ){ @Produces fun produceClient (): CalculatorApiClient { val baseUrl = \"https://empty.url\" val restConf = RestClientConfiguration . withUrl ( baseUrl ). build () return restClientFactory . instantiate ( restConf , CalculatorApiClient :: class . java ) } } @RestApi class MyApi ( val calculator : CalculatorApiClient ) { @GET ( \"/calc/2/plus/2\" ) fun calculateTwoPlusTwo () = calculator . plus ( 2 , 2 ) } Java import injector.* ; import io.vertx.core.Future ; import kos.core.client.RestClientConfiguration ; @Singleton public class CalculatorApiClientConfiguration { final RestClientFactory restClientFactory ; public CalculatorApiClientConfiguration ( RestClientFactory restClientFactory ) { this . restClientFactory = restClientFactory ; } @Produces CalculatorApiClient produceClient () { val baseUrl = \"https://empty.url\" ; val restConf = RestClientConfiguration . withUrl ( baseUrl ). build (); return restClientFactory . instantiate ( restConf , CalculatorApiClient . java ); } } @RestApi public class MyApi { final CalculatorApiClient calculator ; public MyApi ( CalculatorApiClient calculator ) { this . calculator = calculator ; } @GET ( \"/calc/2/plus/2\" ) Future < Integer > calculateTwoPlusTwo () { return calculator . plus ( 2 , 2 ); } } The example above will use Injector to produce an instance of our client whenever one needs to be injected in our controller. As our controller is a @Singleton , only one instance will be created. Info For optimal resource usage, you might want to cache the created client. RestClientConfiguration Here are the main methods of the RestClientConfiguration class: withUrl : Set the base URL withHeaders : Set custom headers withRestClientSerializer : Define how successful responses will be serialized withStringConverter : Allow customizing how parameters and headers will be converted from Objects to String withClient : Allow defining a custom Vert.x WebClient instance - useful when we need to perform an advanced client configuration.","title":"Rest Clients"},{"location":"manual/developer/rest-clients/#rest-clients","text":"Write down rest clients is usually a task most people don't like to do, especially in the JVM ecosystem. We have several Http abstractions and implementations, each of them with different dependency stack. Vert.x team introduced a web client API on their vertx-web module, which is managed by vertx-core connection pool for optimal resource utilization. By borrowing a few ideas from Netflix Feign and other well known open source frameworks, Kos provides a simple API to create Rest Clients that takes advantage of the well crafted vertx-web module. It is behaves similarly to the Rest API: it uses the same annotations as the Rest Api to map endpoints to methods the same applies when mapping path parameters , query parameters or headers to method parameters it also uses the same Body annotation to serialize and send request payloads","title":"Rest Clients"},{"location":"manual/developer/rest-clients/#interfaces-as-api-entrypoint","text":"The biggest difference lies on the fact that you don't write concrete classes to define your Rest Clients, you write interfaces. You also have to annotate them with kos.rest.RestClient instead of the kos.core.RestApi one. Kotlin import kos.rest.* @RestClient ( \"/calc\" ) interface CalculatorApiClient { @GET ( \"/plus/:a/:b\" ) fun plus ( @Param a : Int , @Param b : Int ): Future < Int > @GET ( \"/minus/:a/:b\" ) fun minus ( @Param a : Int , @Param b : Int ): Future < Int > } Java import kos.rest.* ; @RestClient ( \"/calc\" ) interface CalculatorApiClient { @GET ( \"/plus/:a/:b\" ) Future < Int > plus ( @Param Integer a , @Param Integer b ); @GET ( \"/minus/:a/:b\" ) Future < Int > minus ( @Param Integer a , @Param Integer b ); }","title":"Interfaces as API entrypoint"},{"location":"manual/developer/rest-clients/#consuming-responses-to-the-http-server","text":"Kos Rest Client's will infer the response from the return type defined on your functions: void : methods that doesn't return a value will make the call to the desired API in a fire-and-forget fashion, completely ignoring the response received by the server. io.vertx.core.Future<?> : Http Clients will hold the received response in a Future object allowing you to handle the response asynchronously on your first convenience. As you probably notice, Http Clients never blocks the event loop. This comes with a few restrictions though: You have no automated mechanism to map failures into objects In case of Http responses other than 2xx an Exception ( UnexpectedRestClientResponse ) will be set as future Response allowing you to manually handle the unexpected behavior.","title":"Consuming responses to the Http Server"},{"location":"manual/developer/rest-clients/#instantiating-your-rest-client","text":"As the Rest Client API only takes care of mapping endpoints it doesn't know anything else about your client. By using the RestClientFactory.instantiate(RestClientConfiguration, T) method, you can define how it will work, which URL should be used to reach the server, how authentication might work, etc. Kotlin import injector.* import kos.core.client.RestClientConfiguration @Singleton class CalculatorApiClientConfiguration ( val restClientFactory : RestClientFactory ){ @Produces fun produceClient (): CalculatorApiClient { val baseUrl = \"https://empty.url\" val restConf = RestClientConfiguration . withUrl ( baseUrl ). build () return restClientFactory . instantiate ( restConf , CalculatorApiClient :: class . java ) } } @RestApi class MyApi ( val calculator : CalculatorApiClient ) { @GET ( \"/calc/2/plus/2\" ) fun calculateTwoPlusTwo () = calculator . plus ( 2 , 2 ) } Java import injector.* ; import io.vertx.core.Future ; import kos.core.client.RestClientConfiguration ; @Singleton public class CalculatorApiClientConfiguration { final RestClientFactory restClientFactory ; public CalculatorApiClientConfiguration ( RestClientFactory restClientFactory ) { this . restClientFactory = restClientFactory ; } @Produces CalculatorApiClient produceClient () { val baseUrl = \"https://empty.url\" ; val restConf = RestClientConfiguration . withUrl ( baseUrl ). build (); return restClientFactory . instantiate ( restConf , CalculatorApiClient . java ); } } @RestApi public class MyApi { final CalculatorApiClient calculator ; public MyApi ( CalculatorApiClient calculator ) { this . calculator = calculator ; } @GET ( \"/calc/2/plus/2\" ) Future < Integer > calculateTwoPlusTwo () { return calculator . plus ( 2 , 2 ); } } The example above will use Injector to produce an instance of our client whenever one needs to be injected in our controller. As our controller is a @Singleton , only one instance will be created. Info For optimal resource usage, you might want to cache the created client.","title":"Instantiating your Rest Client"},{"location":"manual/developer/rest-clients/#restclientconfiguration","text":"Here are the main methods of the RestClientConfiguration class: withUrl : Set the base URL withHeaders : Set custom headers withRestClientSerializer : Define how successful responses will be serialized withStringConverter : Allow customizing how parameters and headers will be converted from Objects to String withClient : Allow defining a custom Vert.x WebClient instance - useful when we need to perform an advanced client configuration.","title":"RestClientConfiguration"}]}