{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview \u00b6 Kos is small layer over Vert.x to leverage web developers productivity by providing them a zero-overhead and minimalistic API. It was carefully designed to not hide from developers how the software works underneath. Kos also embrace Vert.x philosophy and doesn't enforce developers to follow opinionated conventions - as all of them are optional - but provide them an easy and transparent mechanism to avoid repetitive tasks. Features \u00b6 a reflection-free layer over Vert.x web API a simplified way to spin up the web server automatically deploy Vert.x Verticles automatically load vertx-config configuration introduce customization entries for sensible mechanisms (like serializers) Motivation \u00b6 Vert.x shines in the JVM ecosystem as blistering fast toolkit to build scalable and reliable web applications. Aside of its well crafted non-blocking event-loop and a versatile multi-propose web layer, it comes with a set of reactive tools and non-blocking drivers that leverages the application performance to another level. It comes though with a trade-off as some may see it as niche solution due to its low-level API. According to a Stack Overflow survey almost 60% of the developers identify themselves as backend-developers. It's known that, aside from a few edge-cases, backend-developers are mostly focused on delivery new features to increase the aggregated value of a program, letting the of perform low-level tuning to software architects and scientists , squeezing bits and bytes whenever possible to reduce cost or improve the user usage experience. Steady, repeatable and predictable (a.k.a. boring ) routine directly conflicts with the developer's desire of learning something new - or arguably more fun. You can see traits of this behaviour everywhere, specially regarding sluggish performance of frameworks, lack of innovative approaches and old-minded communities. Keeping a relevant role in the developers routine by providing an updated and open-minded development alternative, whilst ensuring developers productivity, is definitely a hard task. By keeping Vert.x as foundation of his existence, Kos aims to fill this gap between by encouraging the development of high-performance applications with less hassle. Philosophy \u00b6 These are the principles that guides Kos development: Keep things simple but flexible . Conventions are Pareto-friendly, therefore, doesn't solve all the problems. Kos will simplify things whenever possible, but developers are always free to switch back vanilla Vert.x . Keep it fast . Simplifying repetitive routines should never hurt the software performance. Vert.x as first-class citizen . While Kos wraps some of Vert.x API, it encourages developers to make use of it whenever needed. Kos wrappers always returns the Vert.x equivalent for further usage. Never block the event loop . You may have heard about that before, but it worth to mention you should never block the event-loop. History \u00b6 This project was started between late 2018 and early 2019 on an attempt to provide Sizebay a simple API to replace their previous undertow-based microservices framework. The idea came up when we had the necessity to include more developers on the team and we wanted to avoid them to talk directly to Undertow and XNIO as they was designed as low-level APIs. The project name kos (pronounces like coosh) came from Norwegian and is a word used to describe all the things that make you feel cozy and warm inside. License \u00b6 Kos is release under Apache License 2 terms.","title":"Overview"},{"location":"#overview","text":"Kos is small layer over Vert.x to leverage web developers productivity by providing them a zero-overhead and minimalistic API. It was carefully designed to not hide from developers how the software works underneath. Kos also embrace Vert.x philosophy and doesn't enforce developers to follow opinionated conventions - as all of them are optional - but provide them an easy and transparent mechanism to avoid repetitive tasks.","title":"Overview"},{"location":"#features","text":"a reflection-free layer over Vert.x web API a simplified way to spin up the web server automatically deploy Vert.x Verticles automatically load vertx-config configuration introduce customization entries for sensible mechanisms (like serializers)","title":"Features"},{"location":"#motivation","text":"Vert.x shines in the JVM ecosystem as blistering fast toolkit to build scalable and reliable web applications. Aside of its well crafted non-blocking event-loop and a versatile multi-propose web layer, it comes with a set of reactive tools and non-blocking drivers that leverages the application performance to another level. It comes though with a trade-off as some may see it as niche solution due to its low-level API. According to a Stack Overflow survey almost 60% of the developers identify themselves as backend-developers. It's known that, aside from a few edge-cases, backend-developers are mostly focused on delivery new features to increase the aggregated value of a program, letting the of perform low-level tuning to software architects and scientists , squeezing bits and bytes whenever possible to reduce cost or improve the user usage experience. Steady, repeatable and predictable (a.k.a. boring ) routine directly conflicts with the developer's desire of learning something new - or arguably more fun. You can see traits of this behaviour everywhere, specially regarding sluggish performance of frameworks, lack of innovative approaches and old-minded communities. Keeping a relevant role in the developers routine by providing an updated and open-minded development alternative, whilst ensuring developers productivity, is definitely a hard task. By keeping Vert.x as foundation of his existence, Kos aims to fill this gap between by encouraging the development of high-performance applications with less hassle.","title":"Motivation"},{"location":"#philosophy","text":"These are the principles that guides Kos development: Keep things simple but flexible . Conventions are Pareto-friendly, therefore, doesn't solve all the problems. Kos will simplify things whenever possible, but developers are always free to switch back vanilla Vert.x . Keep it fast . Simplifying repetitive routines should never hurt the software performance. Vert.x as first-class citizen . While Kos wraps some of Vert.x API, it encourages developers to make use of it whenever needed. Kos wrappers always returns the Vert.x equivalent for further usage. Never block the event loop . You may have heard about that before, but it worth to mention you should never block the event-loop.","title":"Philosophy"},{"location":"#history","text":"This project was started between late 2018 and early 2019 on an attempt to provide Sizebay a simple API to replace their previous undertow-based microservices framework. The idea came up when we had the necessity to include more developers on the team and we wanted to avoid them to talk directly to Undertow and XNIO as they was designed as low-level APIs. The project name kos (pronounces like coosh) came from Norwegian and is a word used to describe all the things that make you feel cozy and warm inside.","title":"History"},{"location":"#license","text":"Kos is release under Apache License 2 terms.","title":"License"},{"location":"01-getting-started/","text":"Getting Started \u00b6 Info Don't want to follow the following steps by yourself? What about downloading a blueprint project that you can change according to your needs? Gradle+Kotlin Project [ Download ] [ Source Code ] Maven+Kotlin Project [ Download ] [ Source Code ] Kos is mostly written in Java and carefully designed to be easily integrated other JVM languages like Kotlin and Scala. To import Kos you should include the following libraries on your project. Gradle (kts) dependencies { // Import the Bill of Materials implementation ( platform ( \"io.skullabs.kos:kos-bom:${version_kos}\" )) implementation ( \"io.skullabs.kos:kos-core\" ) compileOnly ( \"io.skullabs.kos:kos-annotations\" ) } Maven (pom.xml) <dependencyManagement> <dependencies> <!-- Import the Bill of Materials --> <dependency> <groupId> io.skullabs.kos </groupId> <artifactId> kos-bom </artifactId> <version> ${version_kos} </version> <type> pom </type> <scope> import </scope> </dependency> </dependencies> </dependencyManagement> <dependencies> <dependency> <groupId> io.skullabs.kos </groupId> <artifactId> kos-core </artifactId> </dependency> <dependency> <groupId> io.skullabs.kos </groupId> <artifactId> kos-annotations </artifactId> </dependency> </dependency> Maven (pom.kts) dependencyManagement { dependencies { // Import the Bill of Materials import ( \"io.skullabs.kos:kos-bom:${kosVersion}\" ) } } dependencies { // Kos Dependencies compile ( \"io.skullabs.kos:kos-core\" ) compile ( \"io.skullabs.kos:kos-injector\" ) provided ( \"io.skullabs.kos:kos-annotations\" ) } Now let's create a simple HelloWorld API. HelloWorldApi.kt @Path ( \"hello\" ) class HelloWorldApi { @GET ( \"world\" ) fun sayHello () = \"Hello World\" } HelloWorldApi.java @Path ( \"hello\" ) class HelloWorldApi { @GET ( \"world\" ) String sayHello () { return \"Hello World\" ; } } Finally, we have to bundle all dependencies together and generate a runnable jar with them. Gradle (kts) // You can use either Shadow or VertX plugin to generate a fat jar // We've picked VertX in this example plugins { id ( \"io.vertx.vertx-plugin\" ) version \"1.0.1\" } vertx { launcher = launcherClass } Maven (pom.xml) <plugin> <artifactId> maven-shade-plugin </artifactId> <version> 3.2.0 </version> <executions> <execution> <id> default-package </id> <phase> package </phase> <goals> <goal> shade </goal> </goals> <configuration> <createDependencyReducedPom> true </createDependencyReducedPom> <dependencyReducedPomLocation> ${project.build.directory}/pom-reduced.xml </dependencyReducedPomLocation> <transformers> <org.apache.maven.plugins.shade.resource.ServicesResourceTransformer /> <org.apache.maven.plugins.shade.resource.ManifestResourceTransformer> <manifestEntries> <Main-Class> kos.core.Launcher </Main-Class> </manifestEntries> </org.apache.maven.plugins.shade.resource.ManifestResourceTransformer> </transformers> </configuration> </execution> </executions> </plugin> Maven (pom.kts) plugins { plugin ( \"org.apache.maven.plugins:maven-shade-plugin:3.2.0\" ) { executions { execution ( id = \"default-package\" , phase = \"package\" , goals = listOf ( \"shade\" )) } configuration { \"createDependencyReducedPom\" to true \"dependencyReducedPomLocation\" to \"\\${project.build.directory}/pom-reduced.xml\" \"transformers\" { \"org.apache.maven.plugins.shade.resource.ServicesResourceTransformer\" {} \"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\" { \"manifestEntries\" { \"Main-Class\" to launcherClass } } } } } } Voila ! Our first Kos software is ready. Let's run it? $ java -jar my-kos-app.jar","title":"Getting Started"},{"location":"01-getting-started/#getting-started","text":"Info Don't want to follow the following steps by yourself? What about downloading a blueprint project that you can change according to your needs? Gradle+Kotlin Project [ Download ] [ Source Code ] Maven+Kotlin Project [ Download ] [ Source Code ] Kos is mostly written in Java and carefully designed to be easily integrated other JVM languages like Kotlin and Scala. To import Kos you should include the following libraries on your project. Gradle (kts) dependencies { // Import the Bill of Materials implementation ( platform ( \"io.skullabs.kos:kos-bom:${version_kos}\" )) implementation ( \"io.skullabs.kos:kos-core\" ) compileOnly ( \"io.skullabs.kos:kos-annotations\" ) } Maven (pom.xml) <dependencyManagement> <dependencies> <!-- Import the Bill of Materials --> <dependency> <groupId> io.skullabs.kos </groupId> <artifactId> kos-bom </artifactId> <version> ${version_kos} </version> <type> pom </type> <scope> import </scope> </dependency> </dependencies> </dependencyManagement> <dependencies> <dependency> <groupId> io.skullabs.kos </groupId> <artifactId> kos-core </artifactId> </dependency> <dependency> <groupId> io.skullabs.kos </groupId> <artifactId> kos-annotations </artifactId> </dependency> </dependency> Maven (pom.kts) dependencyManagement { dependencies { // Import the Bill of Materials import ( \"io.skullabs.kos:kos-bom:${kosVersion}\" ) } } dependencies { // Kos Dependencies compile ( \"io.skullabs.kos:kos-core\" ) compile ( \"io.skullabs.kos:kos-injector\" ) provided ( \"io.skullabs.kos:kos-annotations\" ) } Now let's create a simple HelloWorld API. HelloWorldApi.kt @Path ( \"hello\" ) class HelloWorldApi { @GET ( \"world\" ) fun sayHello () = \"Hello World\" } HelloWorldApi.java @Path ( \"hello\" ) class HelloWorldApi { @GET ( \"world\" ) String sayHello () { return \"Hello World\" ; } } Finally, we have to bundle all dependencies together and generate a runnable jar with them. Gradle (kts) // You can use either Shadow or VertX plugin to generate a fat jar // We've picked VertX in this example plugins { id ( \"io.vertx.vertx-plugin\" ) version \"1.0.1\" } vertx { launcher = launcherClass } Maven (pom.xml) <plugin> <artifactId> maven-shade-plugin </artifactId> <version> 3.2.0 </version> <executions> <execution> <id> default-package </id> <phase> package </phase> <goals> <goal> shade </goal> </goals> <configuration> <createDependencyReducedPom> true </createDependencyReducedPom> <dependencyReducedPomLocation> ${project.build.directory}/pom-reduced.xml </dependencyReducedPomLocation> <transformers> <org.apache.maven.plugins.shade.resource.ServicesResourceTransformer /> <org.apache.maven.plugins.shade.resource.ManifestResourceTransformer> <manifestEntries> <Main-Class> kos.core.Launcher </Main-Class> </manifestEntries> </org.apache.maven.plugins.shade.resource.ManifestResourceTransformer> </transformers> </configuration> </execution> </executions> </plugin> Maven (pom.kts) plugins { plugin ( \"org.apache.maven.plugins:maven-shade-plugin:3.2.0\" ) { executions { execution ( id = \"default-package\" , phase = \"package\" , goals = listOf ( \"shade\" )) } configuration { \"createDependencyReducedPom\" to true \"dependencyReducedPomLocation\" to \"\\${project.build.directory}/pom-reduced.xml\" \"transformers\" { \"org.apache.maven.plugins.shade.resource.ServicesResourceTransformer\" {} \"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\" { \"manifestEntries\" { \"Main-Class\" to launcherClass } } } } } } Voila ! Our first Kos software is ready. Let's run it? $ java -jar my-kos-app.jar","title":"Getting Started"},{"location":"02-rest-apis/","text":"Rest APIs \u00b6 Write down rest API's with Kos is dead simple and, if you've been using Java ecosystem in the last few years you're probably at home. First, be sure you've included kos-annotations in your compilation Class Path, and double-check if you have enabled APT compilation as well (enabled by default only in Java projects). Gradle (kts) compileOnly ( \"io.skullabs.kos:kos-annotations\" ) Maven (pom.xml) <dependency> <groupId> io.skullabs.kos </groupId> <artifactId> kos-annotations </artifactId> </dependency> Maven (pom.kts) provided ( \"io.skullabs.kos:kos-annotations\" ) Classes as API entrypoints \u00b6 Kos relies on JVM classes as entrypoint for your APIs. That said, you should identify your class with the kos.rest.RestApi annotation. It will allow Kos to monitor this class for routes. import kos.rest.* ; @RestApi class MyApi { } If your API contains a common root path that would be shared by two or more endpoints, you can set a root path for you API using the RestApi annotation. import kos.rest.* ; @RestApi ( \"/money\" ) class MyApi { } Info By default kos-annotation module will include your class in the Implementation Loader life cycle, making it automatically managed by the default Implementation Loader mechanism you've configured. For further details, please proceed to this topic. Exposing Methods as Rest endpoints \u00b6 Out-of-box you can expose any public or package default method as Rest endpoint by using one of the following annotations: kos.rest.GET kos.rest.POST kos.rest.PUT kos.rest.DELETE kos.rest.PATCH Please be aware that your REST API methods might behave differently depending on the type of object you define as return type: void : which means your API will receive the request and immediately return 204 as default answer io.vertx.core.Future<?> : which means your API will receive the request and once the Future is resolved a response will be sent back to the Http Client. Plain Objects: which will render render the returned object and sent it automatically as response to the Http Client. import kos.rest.* ; import io.vertx.core.* ; @RestApi ( \"/money\" ) class MyApi { @GET Future < Integer > getMoney (){ Promise < Integer > money = Promise . promise (); // compute my money return money . future (); } }","title":"Rest APIs"},{"location":"02-rest-apis/#rest-apis","text":"Write down rest API's with Kos is dead simple and, if you've been using Java ecosystem in the last few years you're probably at home. First, be sure you've included kos-annotations in your compilation Class Path, and double-check if you have enabled APT compilation as well (enabled by default only in Java projects). Gradle (kts) compileOnly ( \"io.skullabs.kos:kos-annotations\" ) Maven (pom.xml) <dependency> <groupId> io.skullabs.kos </groupId> <artifactId> kos-annotations </artifactId> </dependency> Maven (pom.kts) provided ( \"io.skullabs.kos:kos-annotations\" )","title":"Rest APIs"},{"location":"02-rest-apis/#classes-as-api-entrypoints","text":"Kos relies on JVM classes as entrypoint for your APIs. That said, you should identify your class with the kos.rest.RestApi annotation. It will allow Kos to monitor this class for routes. import kos.rest.* ; @RestApi class MyApi { } If your API contains a common root path that would be shared by two or more endpoints, you can set a root path for you API using the RestApi annotation. import kos.rest.* ; @RestApi ( \"/money\" ) class MyApi { } Info By default kos-annotation module will include your class in the Implementation Loader life cycle, making it automatically managed by the default Implementation Loader mechanism you've configured. For further details, please proceed to this topic.","title":"Classes as API entrypoints"},{"location":"02-rest-apis/#exposing-methods-as-rest-endpoints","text":"Out-of-box you can expose any public or package default method as Rest endpoint by using one of the following annotations: kos.rest.GET kos.rest.POST kos.rest.PUT kos.rest.DELETE kos.rest.PATCH Please be aware that your REST API methods might behave differently depending on the type of object you define as return type: void : which means your API will receive the request and immediately return 204 as default answer io.vertx.core.Future<?> : which means your API will receive the request and once the Future is resolved a response will be sent back to the Http Client. Plain Objects: which will render render the returned object and sent it automatically as response to the Http Client. import kos.rest.* ; import io.vertx.core.* ; @RestApi ( \"/money\" ) class MyApi { @GET Future < Integer > getMoney (){ Promise < Integer > money = Promise . promise (); // compute my money return money . future (); } }","title":"Exposing Methods as Rest endpoints"},{"location":"11-dependency-injection/","text":"Dependency Injection with Kos \u00b6 Kos uses Dependency Injection as a way to allow developers to orthogonally customize applications without changing their codebase. This allowed Kos to generate source code, reducing the amount of code required by developers to write down everyday routines like Rest APIs and Web Clients. Implementation Loaders \u00b6 Internally, Kos refers to Dependency Injection mechanisms as Implementation Loaders . They are responsible to perform two basic tasks the Kos needs all the time: Load an object implementing a given Interface - or extending a given class Load all objects implementing a given Interface - or extending a given class The next topics will cover all DI mechanism provided out-of-box with Kos. JDK Service Provider \u00b6 Although it is not considered a proper Dependency Injection implementation, the ServiceLoader implementation that is bundled with JDK is versatile enough to meet the two above mentioned requirements. If you want to keep you footprint small, Service Provider might be a good solution. It is the default Implementation Loader mechanism. To provide an implementation of a given Kos service all you have to do is implement a given interface (or extend a given class) and create a Service Provider meta information in the META-INF/services folder. For more details on designing a service provide please read the ServiceLoader documentation available here . Injector \u00b6 Info For more details on how Injector works, please proceed to its documentation . Injector is lightweight and zero-overhead dependency injection library for JVM developers. It was carefully designed to make no-use of reflection by having all required meta-information computed at compile time. At runtime it performs only the necessary tasks required to instantiate classes and have its dependencies injected. The result is a blistering fast Dependency Injection implementation that has less than 7kb of footprint. To provide an implementation of a given Kos service all you have to do is implement a given interface (or extend a given class) and annotate with injector.ExposedAs annotation. Also, to make ordinary classes able to be managed by Injector you should annotated them with either injector.Singleton or injector.New . Below you can find a Custom Exception Handler implementation. import injector.ExposedAs ; import kos.core.ExceptionHandler ; import kos.core.Response ; @ExposedAs ( ExceptionHandler . class ) public class CustomExceptionHandler implements ExceptionHandler { public Response handle ( RoutingContext request , Throwable cause ){ if ( cause instanceof IllegalArgumentException ) return Response . BAD_REQUEST ; return Response . of ( cause . getMessage ()). statusCode ( 500 ); } } To use Injector as default Implementation Loader you need to import kos-injector module on your project. Gradle (kts) implementation ( \"io.skullabs.kos:kos-injector\" ) Maven (pom.kts) compile ( \"io.skullabs.kos:kos-injector\" ) Maven (pom.xml) <dependency> <groupId> io.skullabs.kos </groupId> <artifactId> kos-injector </artifactId> </dependency> Guice \u00b6 Info Although we have plans to support Guice in the near future, we hasn't created a module to officially support it yet. Please send us a thumbs up here so we know in what to put more effort for the releases. Custom Dependency Injection Mechanism \u00b6 As mentioned before Kos dependency injection mechanism is quite simple and doesn't enforce you to stick with a single implementation. To provide your own Implementaion Loader you need to implement the kos.core.ImplementationLoader interface. Once you've implemented you need to register it as the default Implementation Loader by exposing it as Service Provider implementation. You can do so by creating a META-INF/services/kos.core.ImplementationLoader file with the canonical name of your just created class inside of it.","title":"Dependency Injection with Kos"},{"location":"11-dependency-injection/#dependency-injection-with-kos","text":"Kos uses Dependency Injection as a way to allow developers to orthogonally customize applications without changing their codebase. This allowed Kos to generate source code, reducing the amount of code required by developers to write down everyday routines like Rest APIs and Web Clients.","title":"Dependency Injection with Kos"},{"location":"11-dependency-injection/#implementation-loaders","text":"Internally, Kos refers to Dependency Injection mechanisms as Implementation Loaders . They are responsible to perform two basic tasks the Kos needs all the time: Load an object implementing a given Interface - or extending a given class Load all objects implementing a given Interface - or extending a given class The next topics will cover all DI mechanism provided out-of-box with Kos.","title":"Implementation Loaders"},{"location":"11-dependency-injection/#jdk-service-provider","text":"Although it is not considered a proper Dependency Injection implementation, the ServiceLoader implementation that is bundled with JDK is versatile enough to meet the two above mentioned requirements. If you want to keep you footprint small, Service Provider might be a good solution. It is the default Implementation Loader mechanism. To provide an implementation of a given Kos service all you have to do is implement a given interface (or extend a given class) and create a Service Provider meta information in the META-INF/services folder. For more details on designing a service provide please read the ServiceLoader documentation available here .","title":"JDK Service Provider"},{"location":"11-dependency-injection/#injector","text":"Info For more details on how Injector works, please proceed to its documentation . Injector is lightweight and zero-overhead dependency injection library for JVM developers. It was carefully designed to make no-use of reflection by having all required meta-information computed at compile time. At runtime it performs only the necessary tasks required to instantiate classes and have its dependencies injected. The result is a blistering fast Dependency Injection implementation that has less than 7kb of footprint. To provide an implementation of a given Kos service all you have to do is implement a given interface (or extend a given class) and annotate with injector.ExposedAs annotation. Also, to make ordinary classes able to be managed by Injector you should annotated them with either injector.Singleton or injector.New . Below you can find a Custom Exception Handler implementation. import injector.ExposedAs ; import kos.core.ExceptionHandler ; import kos.core.Response ; @ExposedAs ( ExceptionHandler . class ) public class CustomExceptionHandler implements ExceptionHandler { public Response handle ( RoutingContext request , Throwable cause ){ if ( cause instanceof IllegalArgumentException ) return Response . BAD_REQUEST ; return Response . of ( cause . getMessage ()). statusCode ( 500 ); } } To use Injector as default Implementation Loader you need to import kos-injector module on your project. Gradle (kts) implementation ( \"io.skullabs.kos:kos-injector\" ) Maven (pom.kts) compile ( \"io.skullabs.kos:kos-injector\" ) Maven (pom.xml) <dependency> <groupId> io.skullabs.kos </groupId> <artifactId> kos-injector </artifactId> </dependency>","title":"Injector"},{"location":"11-dependency-injection/#guice","text":"Info Although we have plans to support Guice in the near future, we hasn't created a module to officially support it yet. Please send us a thumbs up here so we know in what to put more effort for the releases.","title":"Guice"},{"location":"11-dependency-injection/#custom-dependency-injection-mechanism","text":"As mentioned before Kos dependency injection mechanism is quite simple and doesn't enforce you to stick with a single implementation. To provide your own Implementaion Loader you need to implement the kos.core.ImplementationLoader interface. Once you've implemented you need to register it as the default Implementation Loader by exposing it as Service Provider implementation. You can do so by creating a META-INF/services/kos.core.ImplementationLoader file with the canonical name of your just created class inside of it.","title":"Custom Dependency Injection Mechanism"},{"location":"21-kos-architecture/","text":"Kos Architecture Overview \u00b6 In the following topics we're going to introduce you the main points that Kos may come in handy on your project, how it reduces boilerplate codes but keeps the performance close to a pure Vert.x solution. Differences between VertX and Kos \u00b6 To understand the benefits of using Kos, lets create a trivial CRUD of User . Below, we have a basic source code that covers the creation, removal and retrieval of user. We'll use it as persistence layer for two experiments: one using Kos and another one using pure Vert.x. User.java import lombok.* ; import java.util.* ; @Data public class User { final UUID id = UUID . randomUUID (); String name ; ZonedDateTime creationDate ; } UserRepository.java import io.vertx.core.* ; import java.time.* ; import java.util.* ; interface UserRepository { Future < User > retrieveUserById ( UUID id ); Future < List < User >> retrieveUsersCreatedBetween ( ZonedDateTime initialDate , ZonedDateTime endDate ); Future < UUID > createUser ( User user ); Future < Void > removeUser ( UUID id ); } It worth mention that: All the example files bellow are written in Java, although it may look similar if written in Kotlin or Scala. User.java is the entity to be stored in the database - later we'll also use it as a model in our Rest API. For brevity, it uses Lombok to make example simpler. UserRepository.java the concrete implementation of our repository. For brevity, we've designed it as an interface. Lets assume that we have a class DefaultUserRepository else where that properly implements the required methods. Vanilla Vert.x Webapp \u00b6 App.java import io.vertx.core.* ; import io.vertx.core.http.* ; import io.vertx.ext.web.* ; import java.util.* ; import lombok.* ; public class App { // 1 private final Vertx vertx = Vertx . create (); private final Logger logger = LoggerFactory . getLogger ( this . getClass ()); void start () { val configRetriever = loadConfigRetriever (); // 2 configRetriever . getConfig ( res -> { if ( res . failed ()) { handleFatalFailure ( \"Failed to load configuration\" , res . cause ()); } else { Router router = Router . router ( vertx ); // 3 // Ensure any POST message will have its body payload buffered before the // expected request handler method is called. router . post (). handler ( BodyHandler . create () ); val config = res . result (); deployVerticlesWithConfig ( router , config ); startVertxHttpServer ( router , config ); } }); } private ConfigRetriever loadConfigRetriever () { val store = new ConfigStoreOptions () . setOptional ( true ) . setType ( \"file\" ) . setFormat ( \"yaml\" ) . setConfig ( new JsonObject (). put ( \"path\" , \"conf/application.yml\" )); val retrieverOptions = new ConfigRetrieverOptions (); retrieverOptions . addStore ( store ); return ConfigRetriever . create ( vertx , retrieverOptions ); } private void deployVerticlesWithConfig ( Router router , JsonObject config ){ val options = new DeploymentOptions (). setConfig ( res . result ()); val repository = new DefaultUserRepository (); val userVerticle = UserApi . with ( router , repository ); vertx . deployVerticle ( verticle , options ); // 4 } private void startVertxHttpServer ( Router router , JsonObject config ){ val httpOptions = new HttpServerOptions ( config ); vertx . createHttpServer ( httpServerOptions ) . requestHandler ( router ) . listen ( res -> { if ( res . failed () ) { handleFatalFailure ( \"Could not start server\" , as . cause () ); } else { val server = res . result (); Runtime . getRuntime (). addShutdownHook ( new Thread ( server :: close )); logger . info ( \"Application started and listening for requests\" ); } }); } private void handleFatalFailure ( String message , Throwable cause ) { log . fatal ( message , cause ); System . exit ( 1 ); } // Starts the application from the command line. public static void main ( String [] args ){ System . setProperty ( // 5 \"vertx.logger-delegate-factory-class-name\" , SLF4JLogDelegateFactory . class . getCanonicalName () ); new App (). start (); } } UserApi.java import io.vertx.core.http.* ; import io.vertx.core.buffer.* ; import io.vertx.core.logging.* ; import io.vertx.core.json.* ; import io.vertx.ext.web.* ; import java.util.* ; import java.time.* ; import lombok.* ; class UserApi { // 6 final Logger logger = LoggerFactory . getLogger ( this . getClass ()); final UserRepository repository ; UserApi ( UserRepository repository ) { this . repository = repository ; } void retrieveUserById ( RoutingContext event ) { val idAsString = event . request (). params (). get ( \"id\" ); val id = isAsString == null ? null : UUID . fromString ( isAsString ); // 7 repository . retrieveUserById ( id ) . setHandler ( UserApi :: defaultResponseHandler ); // 8 } void retrieveUsersCreatedBetween ( RoutingContext event ) { val initialDateAsString = event . request (). params (). get ( \"initDate\" ); val initialDate = ZonedDateTime . parse ( initialDateAsString ); val endDateAsString = event . request (). params (). get ( \"endDate\" ); val endDate = ZonedDateTime . parse ( endDateAsString ); retrieveUsersCreatedBetween ( initialDate , endDate ) . setHandler ( UserApi :: defaultResponseHandler ); } void createUser ( RoutingContext event ) { val user = Json . decodeValue ( context . getBody (), User . class ); createUser ( user ) . setHandler ( UserApi :: defaultResponseHandler ); } void removeUser ( RoutingContext event ) { val idAsString = event . request (). params (). get ( \"id\" ); val id = isAsString == null ? null : UUID . fromString ( isAsString ); removeUser ( id ) . setHandler ( UserApi :: defaultResponseHandler ); } < T > static void defaultResponseHandler ( AsyncResult < T > res ) { // 9 if ( res . failed ()) { sendInternalServerError ( event , res . cause ()); } else { sendOkResponseAsJson ( event , res . result ()); } } static void sendInternalServerError ( RoutingContext event , Throwable cause ) { // 10 val req = event . request (); logger . error ( \"Failed to handle request: \" + req .. method () + \" - \" + . path (), cause ); event . response (). setStatusCode ( 500 ). end (); } static void sendOkResponseAsJson ( RoutingContext event , Object object ) { val buffer = Json . encodeToBuffer ( object ); // 11 event . response () . putHeader ( HttpHeaders . CONTENT_TYPE , \"application/json\" ) . setStatusCode ( 200 ) . end ( buffer ); } static UserApi create ( Router router , UserRepository repository ) { val api = UserApi ( repository ); router . get ( \"/users/:id\" , api :: retrieveUserById ); // 12 router . get ( \"/users/:initDate/:endDate\" , api :: retrieveUsersCreatedBetween ); router . post ( \"/users\" , api :: createUser ); router . delete ( \"/users/:id\" , api :: removeUser ); return api ; } } Although the above application is perfectly efficient and fast as it is reliant on Vert.x core, the code itself is far from simple. Let's dive into the source code and look into the numbered lines to understand what it's actually doing. The App class is responsible for starting the web server, providing everything is absolutely necessary to deploy our verticles. Usually the pieces here configured doesn't change that often. It will read the configuration file as the first thing will happen when the application start, exiting the application once it fails. The router will be used as argument for our verticles. Following the instructions of the official documentation, here it has been configured to eagerly read body payloads received by any POST request. Manually deploying Verticles is not a hard task although it comes with its own challenges. Due to the flexible nature of Vertx Web API, there's not standard way to organize the source code and deploy our web verticles. A simple look into the available vertx examples and you'll easily notice that. Here we've decided to delegate the endpoint mapping to the verticle itself, centralizing the routing strategy in a single place. The JVM ecosystem has several mature and reliable log frameworks which diverges in contract and configuration. Thankfully Vertx Core has it's logging mechanism configurable. Here we forced to use popular SLF4J as logger implementation. This strategy also allows us to provide a self-contained package that doesn't expects command line parameters to spin the application. The UserApi class acts bridge between our Rest API and the UserRepository . Depending on how big are the changes in requirements, this class may have to be changed frequently by the developers. Extracting parameters from the request is a trivial task too. It can be tricky though to parse strings values, check for nullable values and pass the values to the expected business logic (in our case, our repository). Underneath Vert.x makes heavily usage of its netty-based Event Loop implementation. Smart developers will never block the EL and will always rely on non-blocking or asynchronous APIs to perform calls to a downstream service. The caveat though is that we should properly compose Future and Promise objects in order to provide a consistent and integer API to our users. Here we have our centralized handler that is used any time we need to analyze Future objects and send a response to the client of our Rest API. Our naive error handler implementation here is straightforward, sending a simple 500 response to the Http client. Response serialization is something that should be manually handled here and if properly written will not impact that much on developers productivity. As described before, the Route Mapping algorithm has been moved to the UserApi class, as it makes sense to have the mapping and the bridge methods in the same place. Kos webapp \u00b6 The above steps indeed makes sense and covers a fairly amount of features that is expected from a development platform, although one may expect to have less work to bridge their business logic from the network. Kos comes as tool to significantly reduce this layer. UserApi.java import java.util.* ; import java.time.* ; import kos.rest.* ; import lombok.extern.slf4j.Slf4j ; import injector.Singleton ; @Slf4j @Path ( \"users\" ) @Singleton class UserApi { final UserRepository repository ; UserApi ( UserRepository repository ) { this . repository = repository ; } @GET ( \":id\" ) Future < User > retrieveUserById ( @Param UUID id ) { return repository . retrieveUserById ( id ); } @GET ( \":initDate/:endDate\" ) Future < List < User >> retrieveUsersCreatedBetween ( @Param ZonedDateTime initDate , @Param ZonedDateTime endDate ) { return repository . retrieveUsersCreatedBetween ( initDate , endDate ); } @POST Future < UUID > createUser ( User user ) { return repository . createUser ( user ); } @DELETE ( \":id\" ) Future < Void > removeUser ( UUID id ) { return repository . removeUser ( id ); } } It was rather simplified. Let's walk through the biggest differences we have between both examples. The first thing that draws our attention once we read the source code is the introduction of Kos annotations that are used as mapping entry points. It is mainly used to mark routing methods and automatically bind them to a Rest endpoint. Our controller is not being manually bond to the Vert.x Router or event the Vertx instance. In fact, we don't even had to configure a Vertx application at all. Underneath a new Vertx and Router instance will be spun up and use it whenever you use the Kos annotations. The introduction of the injector.Singleton annotation. Kos is very flexible and provides a versatile dependency injection where you can optionally use your favorite Dependency Injection framework. Out-of-box though it only supports Injector and SPI classes - more on that below. Dependency Injection: Kos' Backbone \u00b6 Dependency injection is the literally Kos' backbone. As you can imagine from the previous examples, in order to simplify the way you design a Rest API a few conventions has been adopted to automatically discovery your endpoints, to deploy verticles and even read the configuration file from the file system. Looking to the steps we usually do in order to have a Vert.x application up and running, we figured out that Kos should perform the following during the boot: Load all classes implementing io.vertx.core.Verticle : We need a way to discovery verticles and deploy them automatically. Load configuration automatically: It's also convenient to have the configuration file loaded automatically once the application is started. Discovery Rest endpoints automatically - or at least provide a way for developers to access Vert.x Router . Figure out which (supported) log API the developer is using and make Vert.x use it automatically - instead of manually set a parameter in command line every time you spin up your server. There are multiple ways to achieve these goals, and few libraries can easily provide that for us. There are though a few assumptions that we had to assess them: Everything should be optional. Any automation should be consciously triggered by the developers will. It should have little to no cost during the application startup. It should impose no-overhead in our application runtime. Taking the previously mentioned item 1 as an example, the optimal scenario should deploy all the classes which implements Verticle interface, but only the ones intentionally marked as \"discoverable\". After a few days of research and experiments we can with the idea of using Java 6 Service Provider Interfaces (SPI) to discover those implementations. It obviously fits our requirements, and requires no external dependency. The major limitation of SPI lies on the fact that your classes should have a default (no-args) constructor. This can impose severe restrictions on how developers will bridge their business logic from the Rest API. It forced us to make Dependency Injection customizable . Injector is an optional dependency injector that can be used to surpass such limitations, as it also fits into our requirements, makes no-use of reflection and class loader, and is standalone - no external dependency. A list of alternative supported DI frameworks can be found here . WebService Verticle \u00b6 kos.core.VertxWebServer is an special Verticle implementation that comes with the kos-core module. It is responsible for: Spinning up Vert.x Router and the HttpServer . Discovering Rest endpoints mapped via kos-annotations Trigger all implementations of WebServerEventListener Kos Launcher \u00b6 Kos applications are started by the kos.core.Launcher class. Its main job is: Lookup for all classes that implements Verticle interface - exposed as SPI - and automatically deploy them. Lookup for the first ConfigRetriever implementations - exposed as SPI - and automatically deploy it.","title":"Kos Architecture Overview"},{"location":"21-kos-architecture/#kos-architecture-overview","text":"In the following topics we're going to introduce you the main points that Kos may come in handy on your project, how it reduces boilerplate codes but keeps the performance close to a pure Vert.x solution.","title":"Kos Architecture Overview"},{"location":"21-kos-architecture/#differences-between-vertx-and-kos","text":"To understand the benefits of using Kos, lets create a trivial CRUD of User . Below, we have a basic source code that covers the creation, removal and retrieval of user. We'll use it as persistence layer for two experiments: one using Kos and another one using pure Vert.x. User.java import lombok.* ; import java.util.* ; @Data public class User { final UUID id = UUID . randomUUID (); String name ; ZonedDateTime creationDate ; } UserRepository.java import io.vertx.core.* ; import java.time.* ; import java.util.* ; interface UserRepository { Future < User > retrieveUserById ( UUID id ); Future < List < User >> retrieveUsersCreatedBetween ( ZonedDateTime initialDate , ZonedDateTime endDate ); Future < UUID > createUser ( User user ); Future < Void > removeUser ( UUID id ); } It worth mention that: All the example files bellow are written in Java, although it may look similar if written in Kotlin or Scala. User.java is the entity to be stored in the database - later we'll also use it as a model in our Rest API. For brevity, it uses Lombok to make example simpler. UserRepository.java the concrete implementation of our repository. For brevity, we've designed it as an interface. Lets assume that we have a class DefaultUserRepository else where that properly implements the required methods.","title":"Differences between VertX and Kos"},{"location":"21-kos-architecture/#vanilla-vertx-webapp","text":"App.java import io.vertx.core.* ; import io.vertx.core.http.* ; import io.vertx.ext.web.* ; import java.util.* ; import lombok.* ; public class App { // 1 private final Vertx vertx = Vertx . create (); private final Logger logger = LoggerFactory . getLogger ( this . getClass ()); void start () { val configRetriever = loadConfigRetriever (); // 2 configRetriever . getConfig ( res -> { if ( res . failed ()) { handleFatalFailure ( \"Failed to load configuration\" , res . cause ()); } else { Router router = Router . router ( vertx ); // 3 // Ensure any POST message will have its body payload buffered before the // expected request handler method is called. router . post (). handler ( BodyHandler . create () ); val config = res . result (); deployVerticlesWithConfig ( router , config ); startVertxHttpServer ( router , config ); } }); } private ConfigRetriever loadConfigRetriever () { val store = new ConfigStoreOptions () . setOptional ( true ) . setType ( \"file\" ) . setFormat ( \"yaml\" ) . setConfig ( new JsonObject (). put ( \"path\" , \"conf/application.yml\" )); val retrieverOptions = new ConfigRetrieverOptions (); retrieverOptions . addStore ( store ); return ConfigRetriever . create ( vertx , retrieverOptions ); } private void deployVerticlesWithConfig ( Router router , JsonObject config ){ val options = new DeploymentOptions (). setConfig ( res . result ()); val repository = new DefaultUserRepository (); val userVerticle = UserApi . with ( router , repository ); vertx . deployVerticle ( verticle , options ); // 4 } private void startVertxHttpServer ( Router router , JsonObject config ){ val httpOptions = new HttpServerOptions ( config ); vertx . createHttpServer ( httpServerOptions ) . requestHandler ( router ) . listen ( res -> { if ( res . failed () ) { handleFatalFailure ( \"Could not start server\" , as . cause () ); } else { val server = res . result (); Runtime . getRuntime (). addShutdownHook ( new Thread ( server :: close )); logger . info ( \"Application started and listening for requests\" ); } }); } private void handleFatalFailure ( String message , Throwable cause ) { log . fatal ( message , cause ); System . exit ( 1 ); } // Starts the application from the command line. public static void main ( String [] args ){ System . setProperty ( // 5 \"vertx.logger-delegate-factory-class-name\" , SLF4JLogDelegateFactory . class . getCanonicalName () ); new App (). start (); } } UserApi.java import io.vertx.core.http.* ; import io.vertx.core.buffer.* ; import io.vertx.core.logging.* ; import io.vertx.core.json.* ; import io.vertx.ext.web.* ; import java.util.* ; import java.time.* ; import lombok.* ; class UserApi { // 6 final Logger logger = LoggerFactory . getLogger ( this . getClass ()); final UserRepository repository ; UserApi ( UserRepository repository ) { this . repository = repository ; } void retrieveUserById ( RoutingContext event ) { val idAsString = event . request (). params (). get ( \"id\" ); val id = isAsString == null ? null : UUID . fromString ( isAsString ); // 7 repository . retrieveUserById ( id ) . setHandler ( UserApi :: defaultResponseHandler ); // 8 } void retrieveUsersCreatedBetween ( RoutingContext event ) { val initialDateAsString = event . request (). params (). get ( \"initDate\" ); val initialDate = ZonedDateTime . parse ( initialDateAsString ); val endDateAsString = event . request (). params (). get ( \"endDate\" ); val endDate = ZonedDateTime . parse ( endDateAsString ); retrieveUsersCreatedBetween ( initialDate , endDate ) . setHandler ( UserApi :: defaultResponseHandler ); } void createUser ( RoutingContext event ) { val user = Json . decodeValue ( context . getBody (), User . class ); createUser ( user ) . setHandler ( UserApi :: defaultResponseHandler ); } void removeUser ( RoutingContext event ) { val idAsString = event . request (). params (). get ( \"id\" ); val id = isAsString == null ? null : UUID . fromString ( isAsString ); removeUser ( id ) . setHandler ( UserApi :: defaultResponseHandler ); } < T > static void defaultResponseHandler ( AsyncResult < T > res ) { // 9 if ( res . failed ()) { sendInternalServerError ( event , res . cause ()); } else { sendOkResponseAsJson ( event , res . result ()); } } static void sendInternalServerError ( RoutingContext event , Throwable cause ) { // 10 val req = event . request (); logger . error ( \"Failed to handle request: \" + req .. method () + \" - \" + . path (), cause ); event . response (). setStatusCode ( 500 ). end (); } static void sendOkResponseAsJson ( RoutingContext event , Object object ) { val buffer = Json . encodeToBuffer ( object ); // 11 event . response () . putHeader ( HttpHeaders . CONTENT_TYPE , \"application/json\" ) . setStatusCode ( 200 ) . end ( buffer ); } static UserApi create ( Router router , UserRepository repository ) { val api = UserApi ( repository ); router . get ( \"/users/:id\" , api :: retrieveUserById ); // 12 router . get ( \"/users/:initDate/:endDate\" , api :: retrieveUsersCreatedBetween ); router . post ( \"/users\" , api :: createUser ); router . delete ( \"/users/:id\" , api :: removeUser ); return api ; } } Although the above application is perfectly efficient and fast as it is reliant on Vert.x core, the code itself is far from simple. Let's dive into the source code and look into the numbered lines to understand what it's actually doing. The App class is responsible for starting the web server, providing everything is absolutely necessary to deploy our verticles. Usually the pieces here configured doesn't change that often. It will read the configuration file as the first thing will happen when the application start, exiting the application once it fails. The router will be used as argument for our verticles. Following the instructions of the official documentation, here it has been configured to eagerly read body payloads received by any POST request. Manually deploying Verticles is not a hard task although it comes with its own challenges. Due to the flexible nature of Vertx Web API, there's not standard way to organize the source code and deploy our web verticles. A simple look into the available vertx examples and you'll easily notice that. Here we've decided to delegate the endpoint mapping to the verticle itself, centralizing the routing strategy in a single place. The JVM ecosystem has several mature and reliable log frameworks which diverges in contract and configuration. Thankfully Vertx Core has it's logging mechanism configurable. Here we forced to use popular SLF4J as logger implementation. This strategy also allows us to provide a self-contained package that doesn't expects command line parameters to spin the application. The UserApi class acts bridge between our Rest API and the UserRepository . Depending on how big are the changes in requirements, this class may have to be changed frequently by the developers. Extracting parameters from the request is a trivial task too. It can be tricky though to parse strings values, check for nullable values and pass the values to the expected business logic (in our case, our repository). Underneath Vert.x makes heavily usage of its netty-based Event Loop implementation. Smart developers will never block the EL and will always rely on non-blocking or asynchronous APIs to perform calls to a downstream service. The caveat though is that we should properly compose Future and Promise objects in order to provide a consistent and integer API to our users. Here we have our centralized handler that is used any time we need to analyze Future objects and send a response to the client of our Rest API. Our naive error handler implementation here is straightforward, sending a simple 500 response to the Http client. Response serialization is something that should be manually handled here and if properly written will not impact that much on developers productivity. As described before, the Route Mapping algorithm has been moved to the UserApi class, as it makes sense to have the mapping and the bridge methods in the same place.","title":"Vanilla Vert.x Webapp"},{"location":"21-kos-architecture/#kos-webapp","text":"The above steps indeed makes sense and covers a fairly amount of features that is expected from a development platform, although one may expect to have less work to bridge their business logic from the network. Kos comes as tool to significantly reduce this layer. UserApi.java import java.util.* ; import java.time.* ; import kos.rest.* ; import lombok.extern.slf4j.Slf4j ; import injector.Singleton ; @Slf4j @Path ( \"users\" ) @Singleton class UserApi { final UserRepository repository ; UserApi ( UserRepository repository ) { this . repository = repository ; } @GET ( \":id\" ) Future < User > retrieveUserById ( @Param UUID id ) { return repository . retrieveUserById ( id ); } @GET ( \":initDate/:endDate\" ) Future < List < User >> retrieveUsersCreatedBetween ( @Param ZonedDateTime initDate , @Param ZonedDateTime endDate ) { return repository . retrieveUsersCreatedBetween ( initDate , endDate ); } @POST Future < UUID > createUser ( User user ) { return repository . createUser ( user ); } @DELETE ( \":id\" ) Future < Void > removeUser ( UUID id ) { return repository . removeUser ( id ); } } It was rather simplified. Let's walk through the biggest differences we have between both examples. The first thing that draws our attention once we read the source code is the introduction of Kos annotations that are used as mapping entry points. It is mainly used to mark routing methods and automatically bind them to a Rest endpoint. Our controller is not being manually bond to the Vert.x Router or event the Vertx instance. In fact, we don't even had to configure a Vertx application at all. Underneath a new Vertx and Router instance will be spun up and use it whenever you use the Kos annotations. The introduction of the injector.Singleton annotation. Kos is very flexible and provides a versatile dependency injection where you can optionally use your favorite Dependency Injection framework. Out-of-box though it only supports Injector and SPI classes - more on that below.","title":"Kos webapp"},{"location":"21-kos-architecture/#dependency-injection-kos-backbone","text":"Dependency injection is the literally Kos' backbone. As you can imagine from the previous examples, in order to simplify the way you design a Rest API a few conventions has been adopted to automatically discovery your endpoints, to deploy verticles and even read the configuration file from the file system. Looking to the steps we usually do in order to have a Vert.x application up and running, we figured out that Kos should perform the following during the boot: Load all classes implementing io.vertx.core.Verticle : We need a way to discovery verticles and deploy them automatically. Load configuration automatically: It's also convenient to have the configuration file loaded automatically once the application is started. Discovery Rest endpoints automatically - or at least provide a way for developers to access Vert.x Router . Figure out which (supported) log API the developer is using and make Vert.x use it automatically - instead of manually set a parameter in command line every time you spin up your server. There are multiple ways to achieve these goals, and few libraries can easily provide that for us. There are though a few assumptions that we had to assess them: Everything should be optional. Any automation should be consciously triggered by the developers will. It should have little to no cost during the application startup. It should impose no-overhead in our application runtime. Taking the previously mentioned item 1 as an example, the optimal scenario should deploy all the classes which implements Verticle interface, but only the ones intentionally marked as \"discoverable\". After a few days of research and experiments we can with the idea of using Java 6 Service Provider Interfaces (SPI) to discover those implementations. It obviously fits our requirements, and requires no external dependency. The major limitation of SPI lies on the fact that your classes should have a default (no-args) constructor. This can impose severe restrictions on how developers will bridge their business logic from the Rest API. It forced us to make Dependency Injection customizable . Injector is an optional dependency injector that can be used to surpass such limitations, as it also fits into our requirements, makes no-use of reflection and class loader, and is standalone - no external dependency. A list of alternative supported DI frameworks can be found here .","title":"Dependency Injection: Kos' Backbone"},{"location":"21-kos-architecture/#webservice-verticle","text":"kos.core.VertxWebServer is an special Verticle implementation that comes with the kos-core module. It is responsible for: Spinning up Vert.x Router and the HttpServer . Discovering Rest endpoints mapped via kos-annotations Trigger all implementations of WebServerEventListener","title":"WebService Verticle"},{"location":"21-kos-architecture/#kos-launcher","text":"Kos applications are started by the kos.core.Launcher class. Its main job is: Lookup for all classes that implements Verticle interface - exposed as SPI - and automatically deploy them. Lookup for the first ConfigRetriever implementations - exposed as SPI - and automatically deploy it.","title":"Kos Launcher"}]}